<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cool 3D Explorer Game</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #87CEEB; }
    canvas { display: block; }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 20px;
    }
    #score { font-weight: bold; }
  </style>
</head>
<body>
  <div id="hud">
    <div id="score">Score: 0</div>
  </div>

  <!-- Including Three.js and PointerLockControls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>
  <script src="https://threejs.org/examples/js/controls/PointerLockControls.js"></script>

  <script>
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => controls.lock());
    scene.add(controls.getObject());

    // Movement and jumping logic
    const keys = {};
    let velocity = new THREE.Vector3();
    let canJump = false;
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (e.code === 'Space' && canJump) {
        velocity.y += 0.18;
        canJump = false;
      }
    });
    document.addEventListener('keyup', e => keys[e.code] = false);

    // Materials for terrain
    const materials = {
      grass: new THREE.MeshStandardMaterial({ color: 0x228B22 }),
      dirt: new THREE.MeshStandardMaterial({ color: 0x8B4513 }),
      stone: new THREE.MeshStandardMaterial({ color: 0x708090 }),
      wood: new THREE.MeshStandardMaterial({ color: 0x654321 }),
      leaves: new THREE.MeshStandardMaterial({ color: 0x32CD32 }),
      crystal: new THREE.MeshStandardMaterial({ color: 0xFF00FF }),
    };

    const geometry = new THREE.BoxGeometry(1, 1, 1);

    // Terrain generation with trees and caves
    const worldWidth = 40, worldDepth = 40;
    let score = 0;

    function generateTerrain() {
      for (let x = -worldWidth / 2; x < worldWidth / 2; x++) {
        for (let z = -worldDepth / 2; z < worldDepth / 2; z++) {
          let height = Math.floor(6 + Math.sin(x * 0.2) * 3 + Math.cos(z * 0.2) * 3);

          for (let y = 0; y <= height; y++) {
            let material = y === height ? materials.grass : y >= height - 2 ? materials.dirt : materials.stone;
            const block = new THREE.Mesh(geometry, material);
            block.position.set(x, y - 1, z);
            block.userData.isBlock = true;
            scene.add(block);
          }

          // Trees generation
          if (height > 6 && Math.random() < 0.05) {
            for (let t = 0; t < 3; t++) {
              const trunk = new THREE.Mesh(geometry, materials.wood);
              trunk.position.set(x, height + t, z);
              scene.add(trunk);
            }
            for (let lx = -1; lx <= 1; lx++) {
              for (let lz = -1; lz <= 1; lz++) {
                const leaves = new THREE.Mesh(geometry, materials.leaves);
                leaves.position.set(x + lx, height + 3, z + lz);
                scene.add(leaves);
              }
            }
          }

          // Crystals spawning randomly
          if (height > 6 && Math.random() < 0.02) {
            const crystal = new THREE.Mesh(geometry, materials.crystal);
            crystal.position.set(x, height + 1, z);
            crystal.userData.isCollectible = true;
            scene.add(crystal);
          }
        }
      }
    }

    generateTerrain();

    // Lighting setup
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(10, 20, 10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xcccccc, 0.5));

    // Day-night cycle: changes sky color and light intensity
    let skyColor = new THREE.Color(0x87CEEB); // Day color
    function updateDayNight() {
      const time = (Date.now() / 1000) % 24;
      if (time < 12) {
        skyColor.set(0x87CEEB); // Daytime
        light.intensity = 1;
      } else {
        skyColor.set(0x2c3e50); // Nighttime
        light.intensity = 0.5;
      }
      scene.background = skyColor;
    }

    // Update HUD for score
    function updateHUD() {
      document.getElementById("score").textContent = `Score: ${score}`;
    }

    // Main animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Update time of day and lighting
      updateDayNight();

      // Player movement
      const delta = 0.016;
      const speed = 4.5;
      const move = new THREE.Vector3();
      if (keys['KeyW']) move.z -= 1;
      if (keys['KeyS']) move.z += 1;
      if (keys['KeyA']) move.x -= 1;
      if (keys['KeyD']) move.x += 1;
      move.normalize().applyQuaternion(camera.quaternion);
      controls.moveRight(move.x * speed * delta);
      controls.moveForward(move.z * speed * delta);

      // Gravity and jump logic
      velocity.y -= 9.8 * delta;
      controls.getObject().position.y += velocity.y;
      if (controls.getObject().position.y < 2) {
        velocity.y = 0;
        controls.getObject().position.y = 2;
        canJump = true;
      }

      // Check for collision with crystals (collectibles)
      checkForCollectibles();

      // Update HUD
      updateHUD();

      // Render the scene
      renderer.render(scene, camera);
    }

    // Collectibles (Crystals)
    function checkForCollectibles() {
      const objects = scene.children.filter(obj => obj.userData.isCollectible);
      objects.forEach(obj => {
        if (camera.position.distanceTo(obj.position) < 2) {
          scene.remove(obj);
          score += 10; // Increase score when collecting crystal
        }
      });
    }

    // Camera position to ensure it's looking at the scene
    camera.position.set(0, 10, 20); // Adjust the camera height and distance

    animate();
  </script>
</body>
</html>
