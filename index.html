<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Stickman Game - Custom WASD Mapping + Walk, Run & Jump Animation</title>
  <style>
    body { margin: 0; overflow: hidden; background: linear-gradient(to bottom,#3a3a65 0%,#232337 100%);}
    #info { 
      position: absolute; top: 10px; left: 10px; color: #fff; 
      background: rgba(0,0,0,0.55); padding: 10px 16px; border-radius: 8px; 
      font-family: 'Segoe UI', Arial, sans-serif; font-size:1.08em; box-shadow:0 2px 12px #0006;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="info">
    <b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
    Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
    <b>Arrow keys</b> still use standard mapping<br>
    <b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
    <b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script>
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = null;

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 4, 8);

    let cameraMode = 1; // 1: third-person, 2: first-person, 3: top-down

    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x222233, 1);
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(7, 16, 10);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Soft shadow for realism
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.near = 1;
    dirLight.shadow.camera.far = 30;
    dirLight.shadow.camera.left = -10;
    dirLight.shadow.camera.right = 10;
    dirLight.shadow.camera.top = 10;
    dirLight.shadow.camera.bottom = -10;

    // Ground
    const groundGeometry = new THREE.CircleGeometry(20, 50);
    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x44445A, roughness:0.65 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // Stickman hierarchy (fully connected, all limbs attached)
    const stickman = new THREE.Group();

    // Materials
    const stickMat = new THREE.MeshStandardMaterial({color: 0x18191f, metalness:0.12, roughness:0.5});
    const headMat = new THREE.MeshStandardMaterial({color: 0xffffff, metalness:0.1, roughness:0.3, emissive:0x202034});

    // Body (spine) - ROOT
    const body = new THREE.Mesh(
      new THREE.CylinderGeometry(0.08, 0.09, 0.8, 14),
      stickMat
    );
    body.position.y = 1.7;
    body.castShadow = true;
    stickman.add(body);

    // Shoulders (attach to body)
    const shoulders = new THREE.Mesh(
      new THREE.CylinderGeometry(0.07, 0.07, 0.42, 12),
      stickMat
    );
    shoulders.position.y = 0.42;
    shoulders.rotation.z = Math.PI/2;
    shoulders.castShadow = true;
    body.add(shoulders);

    // Head (attach to body)
    const head = new THREE.Mesh(
      new THREE.SphereGeometry(0.26, 28, 28),
      headMat
    );
    head.position.y = 0.66;
    head.castShadow = true;
    // Simple face
    const eyeGeo = new THREE.SphereGeometry(0.036, 8, 8);
    const eyeMat = new THREE.MeshStandardMaterial({color:0x15151a, emissive:0x0});
    const lEye = new THREE.Mesh(eyeGeo, eyeMat);
    lEye.position.set(-0.08, 0.04, 0.22);
    const rEye = new THREE.Mesh(eyeGeo, eyeMat);
    rEye.position.set(0.08, 0.04, 0.22);
    head.add(lEye); head.add(rEye);
    // Smile
    const smileCurve = new THREE.TorusGeometry(0.09, 0.012, 6, 16, Math.PI);
    const smileMat = new THREE.MeshStandardMaterial({color:0x33334a, metalness:0.15, roughness:0.5});
    const smile = new THREE.Mesh(smileCurve, smileMat);
    smile.position.set(0, -0.04, 0.22);
    smile.rotation.x = Math.PI/2;
    head.add(smile);

    body.add(head);

    // Hips (attach to body)
    const hips = new THREE.Mesh(
      new THREE.CylinderGeometry(0.07, 0.07, 0.32, 12),
      stickMat
    );
    hips.position.y = -0.43;
    hips.rotation.z = Math.PI/2;
    hips.castShadow = true;
    body.add(hips);

    // LEFT ARM (shoulders as parent)
    const leftArm = new THREE.Group();
    leftArm.position.set(-0.22, 0.0, 0); // relative to shoulders center
    shoulders.add(leftArm);

    const upperArmL = new THREE.Mesh(
      new THREE.CylinderGeometry(0.045, 0.055, 0.55, 10),
      stickMat
    );
    upperArmL.position.y = -0.27;
    upperArmL.castShadow = true;
    leftArm.add(upperArmL);

    const leftForearm = new THREE.Group();
    leftForearm.position.y = -0.55;
    const lowerArmL = new THREE.Mesh(
      new THREE.CylinderGeometry(0.042, 0.045, 0.45, 10),
      stickMat
    );
    lowerArmL.position.y = -0.225;
    lowerArmL.castShadow = true;
    leftForearm.add(lowerArmL);
    leftArm.add(leftForearm);

    // Simple hand
    const leftHand = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 10), headMat);
    leftHand.position.y = -0.46;
    leftForearm.add(leftHand);

    // RIGHT ARM (shoulders as parent)
    const rightArm = new THREE.Group();
    rightArm.position.set(0.22, 0.0, 0); // relative to shoulders center
    shoulders.add(rightArm);

    const upperArmR = new THREE.Mesh(
      new THREE.CylinderGeometry(0.045, 0.055, 0.55, 10),
      stickMat
    );
    upperArmR.position.y = -0.27;
    upperArmR.castShadow = true;
    rightArm.add(upperArmR);

    const rightForearm = new THREE.Group();
    rightForearm.position.y = -0.55;
    const lowerArmR = new THREE.Mesh(
      new THREE.CylinderGeometry(0.042, 0.045, 0.45, 10),
      stickMat
    );
    lowerArmR.position.y = -0.225;
    lowerArmR.castShadow = true;
    rightForearm.add(lowerArmR);
    rightArm.add(rightForearm);

    // Simple hand
    const rightHand = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 10), headMat);
    rightHand.position.y = -0.46;
    rightForearm.add(rightHand);

    // LEFT LEG (hips as parent)
    const leftLeg = new THREE.Group();
    leftLeg.position.set(-0.10, -0.16, 0); // relative to hips center
    hips.add(leftLeg);

    const upperLegL = new THREE.Mesh(
      new THREE.CylinderGeometry(0.05, 0.06, 0.6, 10),
      stickMat
    );
    upperLegL.position.y = -0.3;
    upperLegL.castShadow = true;
    leftLeg.add(upperLegL);

    const leftShin = new THREE.Group();
    leftShin.position.y = -0.6;
    const lowerLegL = new THREE.Mesh(
      new THREE.CylinderGeometry(0.045, 0.05, 0.48, 10),
      stickMat
    );
    lowerLegL.position.y = -0.24;
    lowerLegL.castShadow = true;
    leftShin.add(lowerLegL);
    leftLeg.add(leftShin);

    // Simple foot
    const leftFoot = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.05, 0.22), stickMat);
    leftFoot.position.set(0, -0.23, 0.08);
    leftShin.add(leftFoot);

    // RIGHT LEG (hips as parent)
    const rightLeg = new THREE.Group();
    rightLeg.position.set(0.10, -0.16, 0); // relative to hips center
    hips.add(rightLeg);

    const upperLegR = new THREE.Mesh(
      new THREE.CylinderGeometry(0.05, 0.06, 0.6, 10),
      stickMat
    );
    upperLegR.position.y = -0.3;
    upperLegR.castShadow = true;
    rightLeg.add(upperLegR);

    const rightShin = new THREE.Group();
    rightShin.position.y = -0.6;
    const lowerLegR = new THREE.Mesh(
      new THREE.CylinderGeometry(0.045, 0.05, 0.48, 10),
      stickMat
    );
    lowerLegR.position.y = -0.24;
    lowerLegR.castShadow = true;
    rightShin.add(lowerLegR);
    rightLeg.add(rightShin);

    // Simple foot
    const rightFoot = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.05, 0.22), stickMat);
    rightFoot.position.set(0, -0.23, 0.08);
    rightShin.add(rightFoot);

    scene.add(stickman);

    // Movement state
    let moveBackward = false, moveForward = false, moveLeft = false, moveRight = false;
    let isRunning = false;
    let isJumping = false;
    let isGrounded = true;
    let velocityY = 0;
    const walkSpeed = 0.085;
    const runSpeed = 0.18;
    const jumpStrength = 0.24;
    const gravity = 0.012;
    let walkCycle = 0; // for gait animation

    window.addEventListener('keydown', function(e){
      switch(e.key) {
        case 'w': moveBackward = true; break;
        case 's': moveForward = true; break;
        case 'a': moveLeft = true; break;
        case 'd': moveRight = true; break;
        case 'ArrowUp': moveForward = true; break;
        case 'ArrowDown': moveBackward = true; break;
        case 'ArrowLeft': moveLeft = true; break;
        case 'ArrowRight': moveRight = true; break;
        case 'Shift': isRunning = true; break;
        case ' ': 
          if (isGrounded && !isJumping) {
            isJumping = true;
            velocityY = jumpStrength;
          }
          break;
        case '1': cameraMode = 1; break;
        case '2': cameraMode = 2; break;
        case '3': cameraMode = 3; break;
      }
    });

    window.addEventListener('keyup', function(e){
      switch(e.key) {
        case 'w': moveBackward = false; break;
        case 's': moveForward = false; break;
        case 'a': moveLeft = false; break;
        case 'd': moveRight = false; break;
        case 'ArrowUp': moveForward = false; break;
        case 'ArrowDown': moveBackward = false; break;
        case 'ArrowLeft': moveLeft = false; break;
        case 'ArrowRight': moveRight = false; break;
        case 'Shift': isRunning = false; break;
      }
    });

    // Mouse orbit controls (always enabled)
    let azimuth = 0;
    let polar = Math.PI/5;
    let radius = 8;
    const minPolar = 0.12;
    const maxPolar = Math.PI/2 - 0.05;

    let lastMouse = {x: window.innerWidth/2, y: window.innerHeight/2};
    let mouseInitialized = false;
    const mouseSensitivity = 0.0052;

    document.addEventListener('mousemove', function(e){
      if (cameraMode === 2) return;
      if (!mouseInitialized) {
        lastMouse.x = e.clientX; lastMouse.y = e.clientY;
        mouseInitialized = true;
        return;
      }
      let dx = e.clientX - lastMouse.x;
      let dy = e.clientY - lastMouse.y;
      azimuth -= dx * mouseSensitivity;
      polar -= dy * mouseSensitivity;
      polar = Math.max(minPolar, Math.min(maxPolar, polar));
      lastMouse.x = e.clientX;
      lastMouse.y = e.clientY;
    });

    document.addEventListener('mouseleave', function(){
      mouseInitialized = false;
    });

    renderer.domElement.addEventListener('wheel', function(e){
      if (cameraMode === 2) return;
      radius += e.deltaY * 0.012;
      radius = Math.max(2.2, Math.min(32, radius));
    });

    function updateCamera() {
      stickman.position.y = Math.max(stickman.position.y, 0);
      if (cameraMode === 1) {
        // Third-person (orbit)
        let camX = stickman.position.x + radius * Math.sin(polar) * Math.sin(azimuth);
        let camY = stickman.position.y + radius * Math.cos(polar) + 1.3;
        let camZ = stickman.position.z + radius * Math.sin(polar) * Math.cos(azimuth);
        camera.position.set(camX, camY, camZ);
        camera.lookAt(stickman.position.x, 1.7, stickman.position.z);
      } else if (cameraMode === 2) {
        // First-person (at head)
        camera.position.x = stickman.position.x;
        camera.position.y = stickman.position.y + 2.45;
        camera.position.z = stickman.position.z + 0.23;
        camera.lookAt(
          stickman.position.x,
          stickman.position.y + 2.45,
          stickman.position.z + 2
        );
      } else if (cameraMode === 3) {
        let camX = stickman.position.x + radius * Math.sin(azimuth);
        let camY = stickman.position.y + 15;
        let camZ = stickman.position.z + radius * Math.cos(azimuth);
        camera.position.set(camX, camY, camZ);
        camera.lookAt(stickman.position.x, stickman.position.y, stickman.position.z);
      }
    }

    // Animation logic
    function animateStickman(state) {
      let t = walkCycle;
      if (state === "idle") {
        leftArm.rotation.x = 0;
        rightArm.rotation.x = 0;
        leftForearm.rotation.x = 0;
        rightForearm.rotation.x = 0;
        leftLeg.rotation.x = 0;
        rightLeg.rotation.x = 0;
        leftShin.rotation.x = 0;
        rightShin.rotation.x = 0;
      } else if (state === "walk" || state === "run") {
        let freq = state === "walk" ? 5.2 : 10.5;
        let ampArm = state === "walk" ? 0.55 : 1.18;
        let ampLeg = state === "walk" ? 0.66 : 1.08;
        let shinamp = state === "walk" ? 0.42 : 0.83;
        let phase = t * freq;

        leftArm.rotation.x = Math.sin(phase) * ampArm;
        rightArm.rotation.x = Math.sin(phase + Math.PI) * ampArm;
        leftForearm.rotation.x = Math.abs(Math.sin(phase + Math.PI/4)) * 0.18;
        rightForearm.rotation.x = Math.abs(Math.sin(phase + Math.PI/4 + Math.PI)) * 0.18;

        leftLeg.rotation.x = Math.sin(phase) * ampLeg;
        rightLeg.rotation.x = Math.sin(phase + Math.PI) * ampLeg;
        leftShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4)) * shinamp;
        rightShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4 + Math.PI)) * shinamp;
      } else if (state === "jump") {
        leftArm.rotation.x = -1.08;
        rightArm.rotation.x = -1.08;
        leftForearm.rotation.x = -0.34;
        rightForearm.rotation.x = -0.34;
        leftLeg.rotation.x = 0.7;
        rightLeg.rotation.x = 0.7;
        leftShin.rotation.x = 0.62;
        rightShin.rotation.x = 0.62;
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      // Camera-relative movement
      let dx = 0, dz = 0;
      if (moveForward) {
        dx += Math.sin(azimuth) * walkSpeed;
        dz += Math.cos(azimuth) * walkSpeed;
      }
      if (moveBackward) {
        dx -= Math.sin(azimuth) * walkSpeed;
        dz -= Math.cos(azimuth) * walkSpeed;
      }
      if (moveLeft) {
        dx += Math.sin(azimuth - Math.PI/2) * walkSpeed;
        dz += Math.cos(azimuth - Math.PI/2) * walkSpeed;
      }
      if (moveRight) {
        dx += Math.sin(azimuth + Math.PI/2) * walkSpeed;
        dz += Math.cos(azimuth + Math.PI/2) * walkSpeed;
      }
      if ((moveForward || moveBackward || moveLeft || moveRight) && isRunning) {
        dx *= runSpeed / walkSpeed;
        dz *= runSpeed / walkSpeed;
      }
      stickman.position.x += dx;
      stickman.position.z += dz;

      // Jumping/Gravity
      if(isJumping || !isGrounded) {
        stickman.position.y += velocityY;
        velocityY -= gravity;
        if(stickman.position.y <= 0) {
          stickman.position.y = 0;
          isJumping = false;
          isGrounded = true;
          velocityY = 0;
        } else {
          isGrounded = false;
        }
      } else {
        stickman.position.y = 0;
      }

      // Face direction of movement (except top-down)
      if (cameraMode !== 3 && (dx !== 0 || dz !== 0)) {
        stickman.rotation.y = Math.atan2(dx, dz);
      }

      // Animation state
      let state = "idle";
      if(isJumping || !isGrounded) state = "jump";
      else if(dx !== 0 || dz !== 0) state = isRunning ? "run" : "walk";
      animateStickman(state);

      // Animate walk cycle
      if(state === "walk" || state === "run") walkCycle += isRunning ? 0.18 : 0.085;
      else walkCycle += 0.012;

      updateCamera();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
