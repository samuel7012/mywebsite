<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Plane Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; }
  </style>
</head>
<body>
  <div id="info">
    <b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
    <b>Arrow keys</b> also move the plane<br>
    Hold <b>Shift</b> to boost<br>
    <b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down<br>
    <b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script>
    // --- Scene & Camera ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1b1e2e);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 15);

    let cameraMode = 1; // 1: third, 2: first, 3: top-down

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0xaaaaee, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(15, 30, 15);
    scene.add(dirLight);

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(120, 120),
      new THREE.MeshStandardMaterial({ color: 0x333347, metalness: 0.3, roughness: 0.8 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.position.y = 0;
    scene.add(ground);

    // --- Plane Model ---
    const plane = new THREE.Group();

    // Materials
    const matBody = new THREE.MeshStandardMaterial({color:0x1976d2, metalness:0.7, roughness:0.32});
    const matNose = new THREE.MeshStandardMaterial({color:0xcccccc, metalness:0.8, roughness:0.18});
    const matWing = new THREE.MeshStandardMaterial({color:0x5563d2, metalness:0.7, roughness:0.23});
    const matGlass = new THREE.MeshStandardMaterial({color:0xffff99, metalness:0.4, roughness:0.08, emissive:0x222200});
    const matTail = new THREE.MeshStandardMaterial({color:0xd21515, metalness:0.7, roughness:0.23});

    // Body (fuselage)
    const fuselage = new THREE.Mesh(new THREE.CylinderGeometry(0.55, 0.45, 5.2, 24), matBody);
    fuselage.rotation.z = Math.PI/2;
    plane.add(fuselage);

    // Nose cone
    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.48, 1, 24), matNose);
    nose.position.x = 2.6;
    nose.rotation.z = Math.PI/2;
    plane.add(nose);

    // Cockpit
    const cockpit = new THREE.Mesh(new THREE.SphereGeometry(0.36, 16, 12), matGlass);
    cockpit.position.x = 0.85;
    cockpit.position.y = 0.23;
    cockpit.position.z = 0;
    plane.add(cockpit);

    // Wings
    const wingL = new THREE.Mesh(new THREE.BoxGeometry(2.7, 0.13, 0.7), matWing);
    wingL.position.set(0, 0, -0.65);
    plane.add(wingL);
    const wingR = wingL.clone();
    wingR.position.z = 0.65;
    plane.add(wingR);

    // Tail (vertical stabilizer)
    const tailVert = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.85, 0.6), matTail);
    tailVert.position.set(-2.2, 0.42, 0);
    plane.add(tailVert);

    // Tail (horizontal stabilizers)
    const tailHL = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.13, 0.32), matTail);
    tailHL.position.set(-2.45, 0.11, -0.33);
    plane.add(tailHL);
    const tailHR = tailHL.clone();
    tailHR.position.z = 0.33;
    plane.add(tailHR);

    // Propeller
    const propgroup = new THREE.Group();
    const prop = new THREE.Mesh(new THREE.BoxGeometry(0.12, 1.2, 0.09), matNose);
    propgroup.add(prop);
    const prop2 = prop.clone();
    prop2.rotation.z = Math.PI/2;
    propgroup.add(prop2);
    propgroup.position.x = 3.01;
    plane.add(propgroup);

    // Shadow (for fun)
    const shadow = new THREE.Mesh(
      new THREE.EllipseGeometry(2.2,1.1,24),
      new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.17})
    );
    shadow.rotation.x = -Math.PI/2;
    shadow.position.y = -0.53;
    plane.add(shadow);

    scene.add(plane);

    // --- Controls & Animation State ---
    let moveBackward = false, moveForward = false, moveLeft = false, moveRight = false, isBoost = false;
    const speed = 0.15;
    const boostSpeed = 0.38;
    let propellerAngle = 0;

    window.addEventListener('keydown', function(e){
      switch(e.key) {
        case 'w': moveBackward = true; break;
        case 's': moveForward = true; break;
        case 'a': moveLeft = true; break;
        case 'd': moveRight = true; break;
        case 'ArrowUp': moveForward = true; break;
        case 'ArrowDown': moveBackward = true; break;
        case 'ArrowLeft': moveLeft = true; break;
        case 'ArrowRight': moveRight = true; break;
        case 'Shift': isBoost = true; break;
        case '1': cameraMode = 1; break;
        case '2': cameraMode = 2; break;
        case '3': cameraMode = 3; break;
      }
    });

    window.addEventListener('keyup', function(e){
      switch(e.key) {
        case 'w': moveBackward = false; break;
        case 's': moveForward = false; break;
        case 'a': moveLeft = false; break;
        case 'd': moveRight = false; break;
        case 'ArrowUp': moveForward = false; break;
        case 'ArrowDown': moveBackward = false; break;
        case 'ArrowLeft': moveLeft = false; break;
        case 'ArrowRight': moveRight = false; break;
        case 'Shift': isBoost = false; break;
      }
    });

    // Mouse/camera
    let azimuth = 0;
    let polar = Math.PI/6;
    let radius = 12;
    const minPolar = 0.05;
    const maxPolar = Math.PI/2 - 0.05;
    let lastMouse = {x: window.innerWidth/2, y: window.innerHeight/2};
    let mouseInitialized = false;
    const mouseSensitivity = 0.005;

    document.addEventListener('mousemove', function(e){
      if (cameraMode === 2) return;
      if (!mouseInitialized) {
        lastMouse.x = e.clientX; lastMouse.y = e.clientY;
        mouseInitialized = true;
        return;
      }
      let dx = e.clientX - lastMouse.x;
      let dy = e.clientY - lastMouse.y;
      azimuth -= dx * mouseSensitivity;
      polar -= dy * mouseSensitivity;
      polar = Math.max(minPolar, Math.min(maxPolar, polar));
      lastMouse.x = e.clientX;
      lastMouse.y = e.clientY;
    });

    document.addEventListener('mouseleave', function(){
      mouseInitialized = false;
    });

    renderer.domElement.addEventListener('wheel', function(e){
      if (cameraMode === 2) return;
      radius += e.deltaY * 0.01;
      radius = Math.max(2.5, Math.min(40, radius));
    });

    function updateCamera() {
      if (cameraMode === 1) {
        // Third-person (orbit)
        let camX = plane.position.x + radius * Math.sin(polar) * Math.sin(azimuth);
        let camY = plane.position.y + radius * Math.cos(polar) + 1.5;
        let camZ = plane.position.z + radius * Math.sin(polar) * Math.cos(azimuth);
        camera.position.set(camX, camY, camZ);
        camera.lookAt(plane.position.x, 1.1, plane.position.z);
      } else if (cameraMode === 2) {
        // First-person (cockpit)
        camera.position.x = plane.position.x + 0.85*Math.cos(plane.rotation.y);
        camera.position.y = plane.position.y + 0.23;
        camera.position.z = plane.position.z + 0.85*Math.sin(plane.rotation.y);
        camera.lookAt(
          plane.position.x + Math.cos(plane.rotation.y)*8,
          plane.position.y + 0.23,
          plane.position.z + Math.sin(plane.rotation.y)*8
        );
      } else if (cameraMode === 3) {
        // Top-down
        let camX = plane.position.x + radius * Math.sin(azimuth);
        let camY = plane.position.y + 24;
        let camZ = plane.position.z + radius * Math.cos(azimuth);
        camera.position.set(camX, camY, camZ);
        camera.lookAt(plane.position.x, plane.position.y, plane.position.z);
      }
    }

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);

      // Movement vector (camera-relative)
      let dx = 0, dz = 0;
      let curSpeed = isBoost ? boostSpeed : speed;

      if (moveForward) {
        dx += Math.sin(azimuth) * curSpeed;
        dz += Math.cos(azimuth) * curSpeed;
      }
      if (moveBackward) {
        dx -= Math.sin(azimuth) * curSpeed;
        dz -= Math.cos(azimuth) * curSpeed;
      }
      if (moveLeft) {
        dx += Math.sin(azimuth - Math.PI/2) * curSpeed;
        dz += Math.cos(azimuth - Math.PI/2) * curSpeed;
      }
      if (moveRight) {
        dx += Math.sin(azimuth + Math.PI/2) * curSpeed;
        dz += Math.cos(azimuth + Math.PI/2) * curSpeed;
      }
      plane.position.x += dx;
      plane.position.z += dz;

      // Face movement direction (except top-down)
      if (cameraMode !== 3 && (dx !== 0 || dz !== 0)) {
        plane.rotation.y = Math.atan2(dx, dz);
      }

      // Animate propeller
      propellerAngle += (isBoost ? 0.7 : 0.32);
      propgroup.rotation.x = propellerAngle;

      // Animate shadow (squash when moving fast)
      shadow.scale.x = 1.15 + (isBoost ? 0.9 : 0.2);

      updateCamera();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
