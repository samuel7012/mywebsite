<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>No j-- this is not finished</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0,0,0,0.5);
      padding: 8px;
      border-radius: 5px;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <div id="info">
    <b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
    Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
    <b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
    <b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script>
    // Your existing code goes here (scene, stickman, controls, animation, etc.)
    // This example will focus on injecting an endless platform

    // Initialize platform segments
    const platformSegments = [];
    const platformWidth = 10;
    const segmentLength = 40;
    const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });

    function createPlatformSegment(zOffset) {
      const geometry = new THREE.PlaneGeometry(platformWidth, segmentLength);
      const mesh = new THREE.Mesh(geometry, platformMaterial);
      mesh.rotation.x = -Math.PI / 2;
      mesh.position.z = zOffset;
      mesh.receiveShadow = true;
      scene.add(mesh);
      platformSegments.push(mesh);
    }

    function updatePlatforms() {
      const playerZ = stickman.position.z;
      const bufferDistance = segmentLength * 2;
      const farthestZ = platformSegments[platformSegments.length - 1].position.z;

      // Add new segment ahead if needed
      if (playerZ + bufferDistance > farthestZ) {
        createPlatformSegment(farthestZ + segmentLength);
      }

      // Remove segment behind if too far
      if (platformSegments.length > 0 && playerZ - bufferDistance > platformSegments[0].position.z + segmentLength) {
        const old = platformSegments.shift();
        scene.remove(old);
        old.geometry.dispose();
        old.material.dispose();
      }
    }

    // Preload initial segments
    for (let i = 0; i < 5; i++) {
      createPlatformSegment(i * segmentLength);
    }

    // Override your animate loop or insert this inside
    function animate() {
      requestAnimationFrame(animate);
      updatePlatforms();
      updateCamera();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
