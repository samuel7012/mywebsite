<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blobby Goo Party</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }

    canvas {
      display: block;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
<canvas id="gooCanvas"></canvas>

<script>
const canvas = document.getElementById('gooCanvas');
const ctx = canvas.getContext('2d');
let width, height;

function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

class Node {
  constructor(x, y, angle, radius, center) {
    this.center = center;
    this.angle = angle;
    this.radius = radius;
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
  }

  update() {
    this.targetX = this.center.x + Math.cos(this.angle) * this.radius;
    this.targetY = this.center.y + Math.sin(this.angle) * this.radius;

    let dx = this.targetX - this.x;
    let dy = this.targetY - this.y;
    this.vx += dx * 0.1;
    this.vy += dy * 0.1;

    this.vx *= 0.8;
    this.vy *= 0.8;

    this.x += this.vx;
    this.y += this.vy;
  }
}

class Blob {
  constructor(x, y, color = '#00bfff') {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 3;
    this.vy = (Math.random() - 0.5) * 3;
    this.radius = 40 + Math.random() * 20;
    this.color = color;
    this.nodes = [];

    const nodeCount = 20;

    for (let i = 0; i < nodeCount; i++) {
      let angle = (Math.PI * 2 / nodeCount) * i;
      let nx = x + Math.cos(angle) * this.radius;
      let ny = y + Math.sin(angle) * this.radius;
      this.nodes.push(new Node(nx, ny, angle, this.radius, this));
    }
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;

    if (this.x - this.radius < 0 || this.x + this.radius > width) this.vx *= -1;
    if (this.y - this.radius < 0 || this.y + this.radius > height) this.vy *= -1;

    for (let node of this.nodes) {
      node.center = this;
      node.update();
    }
  }

  draw(ctx) {
    ctx.save();
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(this.nodes[0].x, this.nodes[0].y);
    for (let i = 1; i < this.nodes.length; i++) {
      const current = this.nodes[i];
      const prev = this.nodes[i - 1];
      const cx = (prev.x + current.x) / 2;
      const cy = (prev.y + current.y) / 2;
      ctx.quadraticCurveTo(prev.x, prev.y, cx, cy);
    }
    const first = this.nodes[0];
    const last = this.nodes[this.nodes.length - 1];
    const cx = (last.x + first.x) / 2;
    const cy = (last.y + first.y) / 2;
    ctx.quadraticCurveTo(last.x, last.y, cx, cy);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
}

// Generate multiple blobs
const blobs = [];
const blobCount = 5; // change this to make more/less blobs

for (let i = 0; i < blobCount; i++) {
  const x = Math.random() * width;
  const y = Math.random() * height;
  blobs.push(new Blob(x, y));
}

function animate() {
  ctx.clearRect(0, 0, width, height);
  ctx.imageSmoothingEnabled = false;

  for (let blob of blobs) {
    blob.update();
    blob.draw(ctx);
  }

  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
