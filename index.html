<html lang="en">
<head>
<meta charset="UTF-8">
  <title>bruh are u even reading this</title>
<style>
body { margin: 0; overflow: hidden; }
#info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; }
</style>
</head>
<body>
<div id="info">
<b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
<b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
<b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 8, 12);
camera.lookAt(5, 5, 5);
let cameraMode = 1; // 1: third-person, 2: first-person, 3: top-down
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Original Ground (Visual only)
const groundGeometry = new THREE.PlaneGeometry(100, 100);
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// Endless Platforms (Minimal Addition)
const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
const platforms = [];

for (let i = -10; i <= 10; i++) {
  for (let j = -10; j <= 10; j++) {
    const tile = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 2), platformMaterial);
    tile.position.set(i * 2, 5, j * 2);
    tile.userData = {
      width: 2,
      height: 0.1,
      depth: 2,
      solid: true
    };
    scene.add(tile);
    platforms.push(tile);
  }
}

// *** Walls added here ***
const wallGeometry = new THREE.BoxGeometry(2, 4, 0.5);
const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });

const wallPositions = [
  {x: 5, y: 7, z: 0},
  {x: 7, y: 7, z: 0},
  {x: 9, y: 7, z: 0},
  {x: 5, y: 7, z: 2},
  {x: 5, y: 7, z: -2}
];

wallPositions.forEach(pos => {
  const wall = new THREE.Mesh(wallGeometry, wallMaterial);
  wall.position.set(pos.x, pos.y, pos.z);
  scene.add(wall);
});

// Stickman group (perfect stickman proportions and joints)
const stickman = new THREE.Group();

// Materials
const stickMat = new THREE.MeshStandardMaterial({color: 0x181818});
const headMat = new THREE.MeshStandardMaterial({color: 0xffffff});

// Head (proportionally large)
const head = new THREE.Mesh(
new THREE.SphereGeometry(0.28, 32, 32),
headMat
);
head.position.y = 2.25;
stickman.add(head);

// Body (spine)
const body = new THREE.Mesh(
new THREE.CylinderGeometry(0.06, 0.06, 0.95, 20),
stickMat
);
body.position.y = 1.5;
stickman.add(body);

// Shoulders (joint)
const shoulders = new THREE.Mesh(
new THREE.SphereGeometry(0.09, 20, 16),
stickMat
);
shoulders.position.y = 1.98;
stickman.add(shoulders);

// Hips (joint)
const hips = new THREE.Mesh(
new THREE.SphereGeometry(0.085, 18, 12),
stickMat
);
hips.position.y = 1.02;
stickman.add(hips);

// Arms and Legs as groups for animation
// LEFT ARM
const leftArm = new THREE.Group();
leftArm.position.set(-0.19, 1.9, 0);
stickman.add(leftArm);

// Upper arm
const upperArmL = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14),
stickMat
);
upperArmL.position.y = -0.245;
leftArm.add(upperArmL);

// Elbow
const elbowL = new THREE.Mesh(
new THREE.SphereGeometry(0.06, 12, 10),
stickMat
);
elbowL.position.y = -0.49;
leftArm.add(elbowL);

// Forearm
const leftForearm = new THREE.Group();
leftForearm.position.y = -0.49;
const lowerArmL = new THREE.Mesh(
new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12),
stickMat
);
lowerArmL.position.y = -0.21;
leftForearm.add(lowerArmL);

// Wrist/Hand
const handL = new THREE.Mesh(
new THREE.SphereGeometry(0.045, 10, 8),
stickMat
);
handL.position.y = -0.42;
leftForearm.add(handL);

leftArm.add(leftForearm);

// RIGHT ARM
const rightArm = new THREE.Group();
rightArm.position.set(0.19, 1.9, 0);
stickman.add(rightArm);

const upperArmR = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14),
stickMat
);
upperArmR.position.y = -0.245;
rightArm.add(upperArmR);

const elbowR = new THREE.Mesh(
new THREE.SphereGeometry(0.06, 12, 10),
stickMat
);
elbowR.position.y = -0.49;
rightArm.add(elbowR);

const rightForearm = new THREE.Group();
rightForearm.position.y = -0.49;
const lowerArmR = new THREE.Mesh(
new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12),
stickMat
);
lowerArmR.position.y = -0.21;
rightForearm.add(lowerArmR);

const handR = new THREE.Mesh(
new THREE.SphereGeometry(0.045, 10, 8),
stickMat
);
handR.position.y = -0.42;
rightForearm.add(handR);

rightArm.add(rightForearm);

// LEFT LEG
const leftLeg = new THREE.Group();
leftLeg.position.set(-0.07, 0.99, 0);
stickman.add(leftLeg);

// Thigh
const upperLegL = new THREE.Mesh(
new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14),
stickMat
);
upperLegL.position.y = -0.29;
leftLeg.add(upperLegL);

// Knee
const kneeL = new THREE.Mesh(
new THREE.SphereGeometry(0.07, 12, 8),
stickMat
);
kneeL.position.y = -0.58;
leftLeg.add(kneeL);

// Shin
const leftShin = new THREE.Group();
leftShin.position.y = -0.58;
const lowerLegL = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12),
stickMat
);
lowerLegL.position.y = -0.245;
leftShin.add(lowerLegL);

// Foot
const footL = new THREE.Mesh(
new THREE.SphereGeometry(0.05, 10, 8),
stickMat
);
footL.position.y = -0.49;
leftShin.add(footL);

leftLeg.add(leftShin);

// RIGHT LEG
const rightLeg = new THREE.Group();
rightLeg.position.set(0.07, 0.99, 0);
stickman.add(rightLeg);

// Thigh
const upperLegR = new THREE.Mesh(
new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14),
stickMat
);
upperLegR.position.y = -0.29;
rightLeg.add(upperLegR);

// Knee
const kneeR = new THREE.Mesh(
new THREE.SphereGeometry(0.07, 12, 8),
stickMat
);
kneeR.position.y = -0.58;
rightLeg.add(kneeR);

// Shin
const rightShin = new THREE.Group();
rightShin.position.y = -0.58;
const lowerLegR = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12),
stickMat
);
lowerLegR.position.y = -0.245;
rightShin.add(lowerLegR);

// Foot
const footR = new THREE.Mesh(
new THREE.SphereGeometry(0.05, 10, 8),
stickMat
);
footR.position.y = -0.49;
rightShin.add(footR);

rightLeg.add(rightShin);

// Add stickman to scene and position
stickman.position.set(5, 6.3, 0);
scene.add(stickman);

// Controls and movement
const keys = {w:false, a:false, s:false, d:false, shift:false, space:false};
window.addEventListener('keydown', e => {
  if(e.key.toLowerCase() === 'w') keys.w = true;
  if(e.key.toLowerCase() === 'a') keys.a = true;
  if(e.key.toLowerCase() === 's') keys.s = true;
  if(e.key.toLowerCase() === 'd') keys.d = true;
  if(e.key.toLowerCase() === 'shift') keys.shift = true;
  if(e.code === 'Space') keys.space = true;
  if(e.key === '1') cameraMode = 1;
  if(e.key === '2') cameraMode = 2;
  if(e.key === '3') cameraMode = 3;
});

window.addEventListener('keyup', e => {
  if(e.key.toLowerCase() === 'w') keys.w = false;
  if(e.key.toLowerCase() === 'a') keys.a = false;
  if(e.key.toLowerCase() === 's') keys.s = false;
  if(e.key.toLowerCase() === 'd') keys.d = false;
  if(e.key.toLowerCase() === 'shift') keys.shift = false;
  if(e.code === 'Space') keys.space = false;
});

// Movement variables
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let canJump = false;

const clock = new THREE.Clock();

// Raycaster for collision detection
const raycaster = new THREE.Raycaster();
const downRaycaster = new THREE.Raycaster();

function collideWithPlatforms(position, size) {
  // AABB collision detection with platforms and walls
  for (const platform of platforms) {
    if (!platform.userData.solid) continue;
    const p = platform.position;
    const w = platform.userData.width / 2;
    const h = platform.userData.height / 2;
    const d = platform.userData.depth / 2;
    // Simple bounding box collision on x, y, z
    if (position.x + size.x/2 > p.x - w && position.x - size.x/2 < p.x + w &&
        position.y - size.y/2 < p.y + h && position.y + size.y/2 > p.y - h &&
        position.z + size.z/2 > p.z - d && position.z - size.z/2 < p.z + d) {
      return platform;
    }
  }
  // Also check walls (which are in scene.children)
  for (const child of scene.children) {
    if (!child.geometry || child === stickman || child === ground) continue;
    if (child.userData.solid === false) continue;
    if (child.geometry.type !== 'BoxGeometry') continue;
    // assume walls are BoxGeometry with userData.solid undefined, treat them as solid
    const p = child.position;
    const w = child.geometry.parameters.width / 2;
    const h = child.geometry.parameters.height / 2;
    const d = child.geometry.parameters.depth / 2;
    if (position.x + size.x/2 > p.x - w && position.x - size.x/2 < p.x + w &&
        position.y - size.y/2 < p.y + h && position.y + size.y/2 > p.y - h &&
        position.z + size.z/2 > p.z - d && position.z - size.z/2 < p.z + d) {
      return child;
    }
  }
  return null;
}

function update() {
  const delta = clock.getDelta();

  // Movement speed
  const speed = keys.shift ? 6 : 3;
  direction.set(0,0,0);
  if(keys.w) direction.z -= 1;
  if(keys.s) direction.z += 1;
  if(keys.a) direction.x -= 1;
  if(keys.d) direction.x += 1;
  direction.normalize();

  // Rotate direction based on camera yaw
  const euler = new THREE.Euler(0, camera.rotation.y, 0, 'YXZ');
  direction.applyEuler(euler);

  // Horizontal velocity
  velocity.x = direction.x * speed;
  velocity.z = direction.z * speed;

  // Gravity and vertical velocity
  velocity.y -= 9.8 * delta; // gravity

  // Jumping
  if (keys.space && canJump) {
    velocity.y = 6;
    canJump = false;
  }

  // New position attempt
  const newPos = stickman.position.clone();
  newPos.addScaledVector(velocity, delta);

  // Check collisions and resolve them
  const stickmanSize = new THREE.Vector3(0.35, 2.5, 0.35); // approx size box
  let collision = collideWithPlatforms(newPos, stickmanSize);

  if (collision) {
    // simple collision resolution: block movement on collision axis
    if (newPos.y < stickman.position.y) {
      // landed on platform or wall
      velocity.y = 0;
      canJump = true;
      newPos.y = collision.position.y + collision.userData.height/2 + stickmanSize.y/2;
    } else {
      // hit ceiling or wall - stop upward movement
      velocity.y = Math.min(velocity.y, 0);
    }
    // For horizontal collision, stop horizontal movement:
    if (Math.abs(newPos.x - stickman.position.x) > 0) newPos.x = stickman.position.x;
    if (Math.abs(newPos.z - stickman.position.z) > 0) newPos.z = stickman.position.z;
  } else {
    canJump = false;
  }

  stickman.position.copy(newPos);

  // Animate arms and legs swinging if moving
  const time = clock.elapsedTime * 5;
  if(direction.length() > 0.1) {
    upperArmL.rotation.x = Math.sin(time) * 0.6;
    upperArmR.rotation.x = Math.sin(time + Math.PI) * 0.6;
    leftForearm.rotation.x = Math.sin(time) * 0.2;
    rightForearm.rotation.x = Math.sin(time + Math.PI) * 0.2;
    upperLegL.rotation.x = Math.sin(time + Math.PI) * 0.7;
    upperLegR.rotation.x = Math.sin(time) * 0.7;
    leftShin.rotation.x = Math.max(0, -Math.sin(time + Math.PI));
    rightShin.rotation.x = Math.max(0, -Math.sin(time));
  } else {
    upperArmL.rotation.x = 0;
    upperArmR.rotation.x = 0;
    leftForearm.rotation.x = 0;
    rightForearm.rotation.x = 0;
    upperLegL.rotation.x = 0;
    upperLegR.rotation.x = 0;
    leftShin.rotation.x = 0;
    rightShin.rotation.x = 0;
  }

  // Camera modes
  switch(cameraMode){
    case 1: // third-person
      {
        const offset = new THREE.Vector3(0,2.5,5);
        offset.applyEuler(new THREE.Euler(0, stickman.rotation.y, 0));
        camera.position.copy(stickman.position).add(offset);
        camera.lookAt(stickman.position.x, stickman.position.y + 1.5, stickman.position.z);
      }
      break;
    case 2: // first-person
      camera.position.copy(stickman.position);
      camera.position.y += 1.7;
      camera.rotation.copy(stickman.rotation);
      break;
    case 3: // top-down
      camera.position.set(stickman.position.x, stickman.position.y + 15, stickman.position.z);
      camera.lookAt(stickman.position);
      break;
  }
}

function animate() {
  requestAnimationFrame(animate);
  update();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
