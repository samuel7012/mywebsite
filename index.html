<html lang="en">
<head>
<meta charset="UTF-8">
  <title>guys im 9 yrs old and im bad at coding dont judge</title>
<style>
body { margin: 0; overflow: hidden; }
#info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; }
#death-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); background: rgba(180,0,0,0.7); color: #fff; padding: 40px; border-radius: 16px; font-size: 2em; display: none; z-index: 10; }
#checkpoint-msg { position: absolute; top: 54%; left: 50%; transform: translate(-50%,-50%); background: rgba(0,140,0,0.7); color: #fff; padding: 26px; border-radius: 12px; font-size: 1.5em; display: none; z-index: 10; }
</style>
</head>
<body>
<div id="info">
<b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
<b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
<b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)
</div>
<div id="death-msg">YOU DIED!</div>
<div id="checkpoint-msg">Checkpoint reached!</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);

let cameraMode = 1; // 1: third-person, 2: first-person, 3: top-down

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Ground
const groundGeometry = new THREE.PlaneGeometry(60, 60);
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x696969 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// Platform creation
const platforms = [];
function createPlatform(x, y, z, width, height, depth, color=0x8888ff) {
  const geometry = new THREE.BoxGeometry(width, height, depth);
  const material = new THREE.MeshStandardMaterial({ color, emissive: 0x222244 });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y + height / 2, z);
  mesh.userData = { width, height, depth };
  scene.add(mesh);
  platforms.push(mesh);
  return mesh;
}

// Checkpoint creation
const checkpoints = [];
const checkpointColors = [0x00ff22, 0x20c0c0, 0xffff00, 0xff44ff];
function createCheckpoint(x, y, z, color=0x00ff22) {
  const geometry = new THREE.CylinderGeometry(0.22, 0.22, 0.7, 24);
  const material = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.6 });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y+0.35, z);
  mesh.userData = { type:'checkpoint' };
  scene.add(mesh);

  const haloGeom = new THREE.TorusGeometry(0.28, 0.04, 16, 32);
  const haloMat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.7 });
  const halo = new THREE.Mesh(haloGeom, haloMat);
  halo.position.y = 0.38;
  halo.rotation.x = Math.PI/2;
  mesh.add(halo);

  checkpoints.push(mesh);
  return mesh;
}

// Obstacles
const obstacles = [];
function createMovingObstacle(x, y, z, axis='x', range=2, speed=0.04, color=0xff2200) {
  const geometry = new THREE.BoxGeometry(0.8, 0.5, 2);
  const material = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.3 });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y+0.25, z);
  mesh.userData = { type:'moving', axis, range, base: {x, y: y+0.25, z}, speed, phase: Math.random()*Math.PI*2 };
  scene.add(mesh);
  obstacles.push(mesh);
  return mesh;
}

// Red rectangular laser obstacles
function createLaserObstacle(x, y, z, length=3, orientation='x') {
  const geometry = (orientation === 'x')
    ? new THREE.BoxGeometry(length, 0.12, 0.24)
    : new THREE.BoxGeometry(0.24, 0.12, length);
  const material = new THREE.MeshStandardMaterial({
    color: 0xff0000,
    emissive: 0xff0000,
    emissiveIntensity: 0.7,
    transparent: true,
    opacity: 0.8
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y, z);
  mesh.userData = { type:'laser', length, orientation };
  scene.add(mesh);
  obstacles.push(mesh);
  return mesh;
}

// Generate platforms, obstacles, checkpoints
const numPlatforms = 30;
let lastPos = {x: 0, y: 0, z: 0};
let checkpointEvery = 8;
let checkpointIdx = 0;

for (let i = 0; i < numPlatforms; i++) {
  const angle = Math.random() * Math.PI * 2;
  const dist = 2.5 + Math.random() * 2;
  const heightStep = 1.7 + Math.random() * 0.5;
  let x = lastPos.x + Math.cos(angle) * dist;
  let z = lastPos.z + Math.sin(angle) * dist;
  let y = lastPos.y + heightStep * (Math.random() < 0.8 ? 1 : 0.45);
  const color = `0x${Math.floor(Math.random()*16777215).toString(16).padStart(6,"0")}`;
  let plat = createPlatform(x, y, z, 2.3 + Math.random()*0.7, 0.4, 2.3 + Math.random()*0.7, color);

  // Add checkpoints
  if (i % checkpointEvery === 0) {
    checkpointIdx = Math.min(Math.floor(i/checkpointEvery), checkpointColors.length-1);
    createCheckpoint(x, y+0.4, z, checkpointColors[checkpointIdx]);
  }

  // Add obstacles
  if (i > 5 && i % 3 === 0) {
    let axis = (i % 2 === 0) ? 'x' : 'z';
    createMovingObstacle(x, y+0.4, z, axis, 1.2+Math.random()*1.5, 0.035+Math.random()*0.03);
  }
  if (i > 8 && i % 4 === 0) {
    let orientation = (i % 2 === 0) ? 'x' : 'z';
    let laserLen = 2.3 + Math.random()*1.5;
    createLaserObstacle(x, y+0.6, z, laserLen, orientation);
  }

  lastPos = {x, y, z};
}

// Stickman character
const stickman = new THREE.Group();

const stickMat = new THREE.MeshStandardMaterial({color: 0x181818});
const headMat = new THREE.MeshStandardMaterial({color: 0xffffff});

const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 32, 32), headMat);
head.position.y = 2.25;
stickman.add(head);

const body = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.95, 20), stickMat);
body.position.y = 1.5;
stickman.add(body);

const shoulders = new THREE.Mesh(new THREE.SphereGeometry(0.09, 20, 16), stickMat);
shoulders.position.y = 1.98;
stickman.add(shoulders);

const hips = new THREE.Mesh(new THREE.SphereGeometry(0.085, 18, 12), stickMat);
hips.position.y = 1.02;
stickman.add(hips);

// Arms and legs (shortened for brevity, same as before)
// -- Left Arm --
const leftArm = new THREE.Group();
leftArm.position.set(-0.19, 1.9, 0);
stickman.add(leftArm);
const upperArmL = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14), stickMat);
upperArmL.position.y = -0.245;
leftArm.add(upperArmL);
const elbowL = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 10), stickMat);
elbowL.position.y = -0.49;
leftArm.add(elbowL);
const leftForearm = new THREE.Group();
leftForearm.position.y = -0.49;
const lowerArmL = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12), stickMat);
lowerArmL.position.y = -0.21;
leftForearm.add(lowerArmL);
const handL = new THREE.Mesh(new THREE.SphereGeometry(0.045, 10, 8), stickMat);
handL.position.y = -0.42;
leftForearm.add(handL);
leftArm.add(leftForearm);
// -- Right Arm --
const rightArm = new THREE.Group();
rightArm.position.set(0.19, 1.9, 0);
stickman.add(rightArm);
const upperArmR = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14), stickMat);
upperArmR.position.y = -0.245;
rightArm.add(upperArmR);
const elbowR = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 10), stickMat);
elbowR.position.y = -0.49;
rightArm.add(elbowR);
const rightForearm = new THREE.Group();
rightForearm.position.y = -0.49;
const lowerArmR = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12), stickMat);
lowerArmR.position.y = -0.21;
rightForearm.add(lowerArmR);
const handR = new THREE.Mesh(new THREE.SphereGeometry(0.045, 10, 8), stickMat);
handR.position.y = -0.42;
rightForearm.add(handR);
rightArm.add(rightForearm);
// -- Left Leg --
const leftLeg = new THREE.Group();
leftLeg.position.set(-0.07, 0.99, 0);
stickman.add(leftLeg);
const upperLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14), stickMat);
upperLegL.position.y = -0.29;
leftLeg.add(upperLegL);
const kneeL = new THREE.Mesh(new THREE.SphereGeometry(0.07, 12, 8), stickMat);
kneeL.position.y = -0.58;
leftLeg.add(kneeL);
const leftShin = new THREE.Group();
leftShin.position.y = -0.58;
const lowerLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12), stickMat);
lowerLegL.position.y = -0.245;
leftShin.add(lowerLegL);
const footL = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 8), stickMat);
footL.position.y = -0.49;
leftShin.add(footL);
leftLeg.add(leftShin);
// -- Right Leg --
const rightLeg = new THREE.Group();
rightLeg.position.set(0.07, 0.99, 0);
stickman.add(rightLeg);
const upperLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14), stickMat);
upperLegR.position.y = -0.29;
rightLeg.add(upperLegR);
const kneeR = new THREE.Mesh(new THREE.SphereGeometry(0.07, 12, 8), stickMat);
kneeR.position.y = -0.58;
rightLeg.add(kneeR);
const rightShin = new THREE.Group();
rightShin.position.y = -0.58;
const lowerLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12), stickMat);
lowerLegR.position.y = -0.245;
rightShin.add(lowerLegR);
const footR = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 8), stickMat);
footR.position.y = -0.49;
rightShin.add(footR);
rightLeg.add(rightShin);

scene.add(stickman);

// Movement state
let moveBackward = false, moveForward = false, moveLeft = false, moveRight = false;
let isRunning = false;
let isJumping = false;
let isGrounded = true;
let velocityY = 0;
const walkSpeed = 0.08;
const runSpeed = 0.16;
const jumpStrength = 0.24;
const gravity = 0.012;
let walkCycle = 0;

window.addEventListener('keydown', function(e){
switch(e.key) {
case 'w': moveBackward = true; break;
case 's': moveForward = true; break;
case 'a': moveLeft = true; break;
case 'd': moveRight = true; break;
case 'Shift': isRunning = true; break;
case ' ': 
if (isGrounded && !isJumping) {
isJumping = true;
velocityY = jumpStrength;
}
break;
case '1': cameraMode = 1; break;
case '2': cameraMode = 2; break;
case '3': cameraMode = 3; break;
}
});
window.addEventListener('keyup', function(e){
switch(e.key) {
case 'w': moveBackward = false; break;
case 's': moveForward = false; break;
case 'a': moveLeft = false; break;
case 'd': moveRight = false; break;
case 'Shift': isRunning = false; break;
}
});

// Mouse orbit controls
let azimuth = 0;
let polar = Math.PI/5;
let radius = 8;
const minPolar = 0.1;
const maxPolar = Math.PI/2 - 0.05;
let lastMouse = {x: window.innerWidth/2, y: window.innerHeight/2};
let mouseInitialized = false;
const mouseSensitivity = 0.005;

document.addEventListener('mousemove', function(e){
if (cameraMode === 2) return;
if (!mouseInitialized) {
lastMouse.x = e.clientX; lastMouse.y = e.clientY;
mouseInitialized = true;
return;
}
let dx = e.clientX - lastMouse.x;
let dy = e.clientY - lastMouse.y;
azimuth -= dx * mouseSensitivity;
polar -= dy * mouseSensitivity;
polar = Math.max(minPolar, Math.min(maxPolar, polar));
lastMouse.x = e.clientX;
lastMouse.y = e.clientY;
});
document.addEventListener('mouseleave', function(){ mouseInitialized = false; });
renderer.domElement.addEventListener('wheel', function(e){
if (cameraMode === 2) return;
radius += e.deltaY * 0.01;
radius = Math.max(2, Math.min(30, radius));
});
function updateCamera() {
  if (cameraMode === 1) { // third-person
    let camX = stickman.position.x + radius * Math.sin(polar) * Math.sin(azimuth);
    let camY = stickman.position.y + radius * Math.cos(polar) + 1;
    let camZ = stickman.position.z + radius * Math.sin(polar) * Math.cos(azimuth);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(stickman.position.x, stickman.position.y + 1.4, stickman.position.z);
  } else if (cameraMode === 2) { // first-person
    // Position camera at head height, looking forward relative to azimuth
    camera.position.set(stickman.position.x, stickman.position.y + 2.25, stickman.position.z);
    // Calculate lookAt point in front of the stickman based on azimuth angle
    const lookX = stickman.position.x + Math.sin(azimuth);
    const lookY = stickman.position.y + 2.25;
    const lookZ = stickman.position.z + Math.cos(azimuth);
    camera.lookAt(lookX, lookY, lookZ);
  } else if (cameraMode === 3) { // top-down
    let camX = stickman.position.x + radius * Math.sin(azimuth);
    let camY = stickman.position.y + 15;
    let camZ = stickman.position.z + radius * Math.cos(azimuth);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(stickman.position.x, stickman.position.y, stickman.position.z);
  }
}

// Animate stickman
function animateStickman(state) {
let t = walkCycle;
if (state === "idle") {
leftArm.rotation.x = 0; rightArm.rotation.x = 0;
leftForearm.rotation.x = 0; rightForearm.rotation.x = 0;
leftLeg.rotation.x = 0; rightLeg.rotation.x = 0;
leftShin.rotation.x = 0; rightShin.rotation.x = 0;
} else if (state === "walk") {
let freq = 5, ampArm = 0.65, ampLeg = 0.7, shinamp = 0.47, phase = t * freq;
leftArm.rotation.x = Math.sin(phase) * ampArm;
rightArm.rotation.x = Math.sin(phase + Math.PI) * ampArm;
leftForearm.rotation.x = 0; rightForearm.rotation.x = 0;
leftLeg.rotation.x = Math.sin(phase) * ampLeg;
rightLeg.rotation.x = Math.sin(phase + Math.PI) * ampLeg;
leftShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4)) * shinamp;
rightShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4 + Math.PI)) * shinamp;
} else if (state === "run") {
let freq = 9.5, ampArm = 1.6, ampLeg = 1.8, shinamp = 1.35, phase = t * freq;
leftArm.rotation.x = Math.sin(phase) * ampArm * 0.6;
rightArm.rotation.x = Math.sin(phase + Math.PI) * ampArm * 0.6;
leftForearm.rotation.x = Math.abs(Math.sin(phase)) * 0.9 - 1.1;
rightForearm.rotation.x = Math.abs(Math.sin(phase + Math.PI)) * 0.9 - 1.1;
leftLeg.rotation.x = Math.sin(phase) * ampLeg;
rightLeg.rotation.x = Math.sin(phase + Math.PI) * ampLeg;
leftShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 6)) * shinamp + 0.13 * Math.abs(Math.sin(phase));
rightShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 6 + Math.PI)) * shinamp + 0.13 * Math.abs(Math.sin(phase + Math.PI));
} else if (state === "jump") {
leftArm.rotation.x = -1.15; rightArm.rotation.x = -1.15;
leftForearm.rotation.x = -0.42; rightForearm.rotation.x = -0.42;
leftLeg.rotation.x = 0.88; rightLeg.rotation.x = 0.88;
leftShin.rotation.x = 0.8; rightShin.rotation.x = 0.8;
}
}

// Checkpoint and death logic
let lastCheckpoint = {x: 0, y: 0, z: 0}; // initial spawn
function showMessage(id, ms=1200) {
  const el = document.getElementById(id);
  el.style.display = 'block';
  setTimeout(()=>{ el.style.display = 'none'; }, ms);
}
function respawn() {
  stickman.position.x = lastCheckpoint.x;
  stickman.position.y = lastCheckpoint.y;
  stickman.position.z = lastCheckpoint.z;
  velocityY = 0;
  isJumping = false;
  isGrounded = true;
  showMessage('death-msg', 1200);
}

// Animate everything
function animate() {
requestAnimationFrame(animate);

// Camera-relative movement
let dx = 0, dz = 0;
if (moveForward) { dx += Math.sin(azimuth) * walkSpeed; dz += Math.cos(azimuth) * walkSpeed; }
if (moveBackward) { dx -= Math.sin(azimuth) * walkSpeed; dz -= Math.cos(azimuth) * walkSpeed; }
if (moveLeft) { dx += Math.sin(azimuth - Math.PI/2) * walkSpeed; dz += Math.cos(azimuth - Math.PI/2) * walkSpeed; }
if (moveRight){ dx += Math.sin(azimuth + Math.PI/2) * walkSpeed; dz += Math.cos(azimuth + Math.PI/2) * walkSpeed; }
if ((moveForward || moveBackward || moveLeft || moveRight) && isRunning) {
dx *= runSpeed / walkSpeed;
dz *= runSpeed / walkSpeed;
}

stickman.position.x += dx;
stickman.position.z += dz;

// Moving obstacles update
for (let obs of obstacles) {
  if (obs.userData.type === 'moving') {
    let {axis, range, base, speed, phase} = obs.userData;
    obs.userData.phase += speed;
    let offset = Math.sin(obs.userData.phase) * range;
    if (axis === 'x') obs.position.x = base.x + offset;
    else obs.position.z = base.z + offset;
  }
}

// Jump & gravity
if (isJumping || !isGrounded) {
  stickman.position.y += velocityY;
  velocityY -= gravity;

  let landed = false;
  for (let plat of platforms) {
    const px = plat.position.x;
    const py = plat.position.y + plat.userData.height / 2;
    const pz = plat.position.z;
    const w = plat.userData.width / 2;
    const d = plat.userData.depth / 2;
    const sx = stickman.position.x;
    const sz = stickman.position.z;
    if (
      sx > px - w && sx < px + w &&
      sz > pz - d && sz < pz + d &&
      stickman.position.y <= py + 0.01 &&
      velocityY <= 0
    ) {
      stickman.position.y = py;
      velocityY = 0;
      isJumping = false;
      isGrounded = true;
      landed = true;
      break;
    }
  }
  if (!landed && stickman.position.y <= 0) {
    stickman.position.y = 0;
    velocityY = 0;
    isJumping = false;
    isGrounded = true;
  } else if (!landed) {
    isGrounded = false;
  }
} else {
  // Check if still on a platform or fell off
  let onSomething = false;
  for (let plat of platforms) {
    const px = plat.position.x;
    const py = plat.position.y + plat.userData.height / 2;
    const pz = plat.position.z;
    const w = plat.userData.width / 2;
    const d = plat.userData.depth / 2;
    const sx = stickman.position.x;
    const sz = stickman.position.z;
    if (
      sx > px - w && sx < px + w &&
      sz > pz - d && sz < pz + d &&
      Math.abs(stickman.position.y - py) < 0.05
    ) {
      onSomething = true;
      break;
    }
  }
  if (!onSomething && stickman.position.y <= 0.01) {
    stickman.position.y = 0;
    isGrounded = true;
  } else if (!onSomething) {
    isGrounded = false;
  }
}

// Moving obstacle & laser collision
let playerBox = {
  x: stickman.position.x,
  y: stickman.position.y + 1.1,
  z: stickman.position.z,
  size: 0.32
};
for (let obs of obstacles) {
  if (obs.userData.type === 'moving') {
    // AABB collision
    let ox = obs.position.x, oy = obs.position.y, oz = obs.position.z;
    let sx = obs.scale.x, sy = obs.scale.y, sz = obs.scale.z;
    let w = obs.geometry.parameters.width/2, h = obs.geometry.parameters.height/2, d = obs.geometry.parameters.depth/2;
    if (
      Math.abs(playerBox.x - ox) < w + playerBox.size &&
      Math.abs(playerBox.y - oy) < h + playerBox.size &&
      Math.abs(playerBox.z - oz) < d + playerBox.size
    ) {
      respawn();
      break;
    }
  }
  if (obs.userData.type === 'laser') {
    let ox = obs.position.x, oy = obs.position.y, oz = obs.position.z;
    let halfLen = (obs.userData.length/2);
    if (obs.userData.orientation === 'x') {
      if (
        (playerBox.y > oy-0.13 && playerBox.y < oy+0.13) &&
        (playerBox.z > oz-0.13 && playerBox.z < oz+0.13) &&
        (playerBox.x > ox-halfLen && playerBox.x < ox+halfLen)
      ) {
        respawn();
        break;
      }
    } else {
      if (
        (playerBox.y > oy-0.13 && playerBox.y < oy+0.13) &&
        (playerBox.x > ox-0.13 && playerBox.x < ox+0.13) &&
        (playerBox.z > oz-halfLen && playerBox.z < oz+halfLen)
      ) {
        respawn();
        break;
      }
    }
  }
}

// Checkpoint collision
for (let cp of checkpoints) {
  let dx = stickman.position.x - cp.position.x;
  let dy = stickman.position.y - cp.position.y;
  let dz = stickman.position.z - cp.position.z;
  let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
  if (dist < 0.55) {
    lastCheckpoint = {
      x: cp.position.x,
      y: cp.position.y+0.27,
      z: cp.position.z
    };
    showMessage('checkpoint-msg', 900);
  }
}

// Face direction of movement
if (cameraMode !== 3 && (dx !== 0 || dz !== 0)) {
stickman.rotation.y = Math.atan2(dx, dz);
}

// Animation state
let state = "idle";
if(isJumping || !isGrounded) state = "jump";
else if(dx !== 0 || dz !== 0) state = isRunning ? "run" : "walk";
animateStickman(state);
if(state === "walk" || state === "run") walkCycle += isRunning ? 0.025 : 0.024;
else walkCycle += 0.012;

updateCamera();
renderer.render(scene, camera);
}
animate();
window.addEventListener('resize', function() {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
