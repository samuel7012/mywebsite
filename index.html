<html lang="en">
<head>
<meta charset="UTF-8">
<title>TESTING IN PROGRES</title>
<style>
body { margin: 0; overflow: hidden; }
#info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; }
</style>
</head>
<body>
<div id="info" style="display:none">
<b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
<b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
<b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
  
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);

let cameraMode = 1; // 1: third-person, 2: first-person, 3: top-down

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Ground
const groundGeometry = new THREE.PlaneGeometry(100, 100);
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// Stickman setup (unchanged) ...
// [stickman code is unchanged â€” skipped here for brevity, you keep your existing code]

// Movement state
let moveBackward = false, moveForward = false, moveLeft = false, moveRight = false;
let isRunning = false;
let isJumping = false;
let isGrounded = true;
let velocityY = 0;
const walkSpeed = 0.08;
const runSpeed = 0.16;
const jumpStrength = 0.24;
const gravity = 0.012;
let walkCycle = 0; // for gait animation

// NEW camera rotation variables
let rotateLeft = false, rotateRight = false;
const cameraRotateSpeed = 0.03;

window.addEventListener('keydown', function(e){
switch(e.key) {
case 'w': moveBackward = true; break;
case 's': moveForward = true; break;
case 'a': moveLeft = true; break;
case 'd': moveRight = true; break;
case 'ArrowLeft': rotateLeft = true; break;       // NEW
case 'ArrowRight': rotateRight = true; break;     // NEW
case 'Shift': isRunning = true; break;
case ' ': 
if (isGrounded && !isJumping) {
isJumping = true;
velocityY = jumpStrength;
}
break;
case '1': cameraMode = 1; break;
case '2': cameraMode = 2; break;
case '3': cameraMode = 3; break;
}
});

window.addEventListener('keyup', function(e){
switch(e.key) {
case 'w': moveBackward = false; break;
case 's': moveForward = false; break;
case 'a': moveLeft = false; break;
case 'd': moveRight = false; break;
case 'ArrowLeft': rotateLeft = false; break;      // NEW
case 'ArrowRight': rotateRight = false; break;    // NEW
case 'Shift': isRunning = false; break;
}
});

// Mouse orbit controls (unchanged) ...
// [mouse control code stays exactly as in your original]

// updateCamera() function unchanged

// animateStickman() function unchanged

// Animate
function animate() {
requestAnimationFrame(animate);

// Camera-relative movement
let dx = 0, dz = 0;
if (moveForward) {
dx += Math.sin(azimuth) * walkSpeed;
dz += Math.cos(azimuth) * walkSpeed;
}
if (moveBackward) {
dx -= Math.sin(azimuth) * walkSpeed;
dz -= Math.cos(azimuth) * walkSpeed;
}
if (moveLeft) {
dx += Math.sin(azimuth - Math.PI/2) * walkSpeed;
dz += Math.cos(azimuth - Math.PI/2) * walkSpeed;
}
if (moveRight) {
dx += Math.sin(azimuth + Math.PI/2) * walkSpeed;
dz += Math.cos(azimuth + Math.PI/2) * walkSpeed;
}

if ((moveForward || moveBackward || moveLeft || moveRight) && isRunning) {
dx *= runSpeed / walkSpeed;
dz *= runSpeed / walkSpeed;
}

stickman.position.x += dx;
stickman.position.z += dz;

// Jumping/Gravity
if(isJumping || !isGrounded) {
stickman.position.y += velocityY;
velocityY -= gravity;
if(stickman.position.y <= 0) {
stickman.position.y = 0;
isJumping = false;
isGrounded = true;
velocityY = 0;
} else {
isGrounded = false;
}
} else {
stickman.position.y = 0;
}

// Face direction of movement (except top-down)
if (cameraMode !== 3 && (dx !== 0 || dz !== 0)) {
stickman.rotation.y = Math.atan2(dx, dz);
}

// Animation state
let state = "idle";
if(isJumping || !isGrounded) state = "jump";
else if(dx !== 0 || dz !== 0) state = isRunning ? "run" : "walk";
animateStickman(state);

// KEY CHANGE: run animation is slower
if(state === "walk" || state === "run") walkCycle += isRunning ? 0.024 : 0.024;
else walkCycle += 0.012;

// NEW: Camera rotation from arrow keys
if (cameraMode !== 3) {
  if (rotateLeft)  azimuth += cameraRotateSpeed;
  if (rotateRight) azimuth -= cameraRotateSpeed;
}

updateCamera();
renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', function() {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
