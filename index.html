<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Three.js City with Collision</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>

// ====== Scene & Renderer ======
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// ====== Player ======
const players = {};
const playerId = "local";
players[playerId] = {
  x: 0, y: 0, z: 0,
  facing: 0,
  state: "idle",
  walkCycle: 0,
  model: new THREE.Group(),
  movement: { running: false }
};

// Simple stickman placeholder
const stickman = new THREE.Mesh(
  new THREE.CapsuleGeometry(0.4, 1.2, 4, 8),
  new THREE.MeshStandardMaterial({ color: 0x00ffcc })
);
stickman.castShadow = true;
players[playerId].model.add(stickman);
scene.add(players[playerId].model);

// ====== City + Colliders ======
const colliders = [];

function createCity(scene) {
  // Ground
  const groundGeo = new THREE.PlaneGeometry(200, 200);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  const gridHelper = new THREE.GridHelper(200, 40, 0x444444, 0x222222);
  scene.add(gridHelper);

  // Buildings
  const buildingMat = new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.2, roughness: 0.8 });
  const buildings = new THREE.Group();

  for (let i = 0; i < 120; i++) {
    const width = 4 + Math.random() * 4;
    const depth = 4 + Math.random() * 4;
    const height = 5 + Math.random() * 25;
    const geo = new THREE.BoxGeometry(width, height, depth);
    const mat = buildingMat.clone();
    mat.color.setHSL(Math.random() * 0.1 + 0.55, 0.1, 0.4 + Math.random() * 0.2);

    const bldg = new THREE.Mesh(geo, mat);
    bldg.position.set(
      (Math.random() - 0.5) * 180,
      height / 2,
      (Math.random() - 0.5) * 180
    );

    if (Math.abs(bldg.position.x) > 20 || Math.abs(bldg.position.z) > 20) {
      bldg.castShadow = true;
      bldg.receiveShadow = true;
      buildings.add(bldg);

      const box = new THREE.Box3().setFromObject(bldg);
      colliders.push(box);
    }
  }

  scene.add(buildings);

  // Lighting
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
  hemiLight.position.set(0, 200, 0);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(60, 100, -30);
  dirLight.castShadow = true;
  dirLight.shadow.camera.top = 80;
  dirLight.shadow.camera.bottom = -80;
  dirLight.shadow.camera.left = -80;
  dirLight.shadow.camera.right = 80;
  scene.add(dirLight);
}
createCity(scene);

// ====== Camera Orbit (Mouse + Arrow Keys + Zoom) ======
let azimuth = 0, polar = Math.PI / 5, radius = 8;
const minPolar = 0.1, maxPolar = Math.PI/2-0.05;
let lastMouse = {x:0, y:0}, mouseInitialized = false;
const mouseSensitivity = 0.005;

document.addEventListener('mousemove', e => {
  if(!mouseInitialized){ lastMouse={x:e.clientX,y:e.clientY}; mouseInitialized=true; return; }
  let dx = e.clientX-lastMouse.x, dy = e.clientY-lastMouse.y;
  azimuth -= dx*mouseSensitivity;
  polar -= dy*mouseSensitivity;
  polar = Math.max(minPolar, Math.min(maxPolar, polar));
  lastMouse = {x:e.clientX, y:e.clientY};
});
document.addEventListener('mouseleave', ()=>mouseInitialized=false);

renderer.domElement.addEventListener('wheel', e=>{
  radius += e.deltaY*0.01; radius=Math.max(2, Math.min(30, radius));
});

// Arrow keys + PageUp/PageDown for camera
const keyState = {left:false, right:false, up:false, down:false, zoomIn:false, zoomOut:false};
const keyOrbitSpeed = 0.02;
const keyZoomSpeed = 0.2;

window.addEventListener('keydown', e=>{
  switch(e.code){
    case 'ArrowLeft': keyState.left=true; break;
    case 'ArrowRight': keyState.right=true; break;
    case 'ArrowUp': keyState.up=true; break;
    case 'ArrowDown': keyState.down=true; break;
    case 'PageUp': keyState.zoomIn=true; break;
    case 'PageDown': keyState.zoomOut=true; break;
  }
});
window.addEventListener('keyup', e=>{
  switch(e.code){
    case 'ArrowLeft': keyState.left=false; break;
    case 'ArrowRight': keyState.right=false; break;
    case 'ArrowUp': keyState.up=false; break;
    case 'ArrowDown': keyState.down=false; break;
    case 'PageUp': keyState.zoomIn=false; break;
    case 'PageDown': keyState.zoomOut=false; break;
  }
});

function updateCameraKeys(){
  if(keyState.left) azimuth -= keyOrbitSpeed;
  if(keyState.right) azimuth += keyOrbitSpeed;
  if(keyState.up) polar -= keyOrbitSpeed;
  if(keyState.down) polar += keyOrbitSpeed;
  polar = Math.max(minPolar, Math.min(maxPolar, polar));
  if(keyState.zoomIn) radius -= keyZoomSpeed;
  if(keyState.zoomOut) radius += keyZoomSpeed;
  radius = Math.max(2, Math.min(30, radius));
}

function updateCamera(target){
  updateCameraKeys();
  const camX = target.x + radius*Math.sin(polar)*Math.sin(azimuth);
  const camY = target.y + radius*Math.cos(polar)+1;
  const camZ = target.z + radius*Math.sin(polar)*Math.cos(azimuth);
  camera.position.set(camX, camY, camZ);
  camera.lookAt(target.x, target.y+1.4, target.z);
}

// ====== Player Movement ======
let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, isRunning=false;
let isJumping=false, isGrounded=true, velocityY=0, gravity=0.04;
const walkSpeed = 0.2, runSpeed = 0.35;

window.addEventListener('keydown', e=>{
  switch(e.code){
    case 'KeyW': moveForward=true; break;
    case 'KeyS': moveBackward=true; break;
    case 'KeyA': moveLeft=true; break;
    case 'KeyD': moveRight=true; break;
    case 'ShiftLeft': isRunning=true; break;
    case 'Space': if(isGrounded){velocityY=0.6; isJumping=true; isGrounded=false;} break;
  }
});
window.addEventListener('keyup', e=>{
  switch(e.code){
    case 'KeyW': moveForward=false; break;
    case 'KeyS': moveBackward=false; break;
    case 'KeyA': moveLeft=false; break;
    case 'KeyD': moveRight=false; break;
    case 'ShiftLeft': isRunning=false; break;
  }
});

// ====== Main Loop ======
let prevTime = performance.now();
function animate(){
  requestAnimationFrame(animate);
  const time = performance.now();
  const dt = Math.min((time-prevTime)/1000,0.05);
  prevTime = time;

  const player = players[playerId];
  let dx=0, dz=0;
  const speed = isRunning ? runSpeed : walkSpeed;
  if(moveForward){ dx+=Math.sin(azimuth)*speed; dz+=Math.cos(azimuth)*speed; }
  if(moveBackward){ dx-=Math.sin(azimuth)*speed; dz-=Math.cos(azimuth)*speed; }
  if(moveLeft){ dx+=Math.sin(azimuth-Math.PI/2)*speed; dz+=Math.cos(azimuth-Math.PI/2)*speed; }
  if(moveRight){ dx+=Math.sin(azimuth+Math.PI/2)*speed; dz+=Math.cos(azimuth+Math.PI/2)*speed; }

  let newX = player.x + dx;
  let newZ = player.z + dz;

  // ===== Collision Detection =====
  const playerBox = new THREE.Box3(
    new THREE.Vector3(newX-0.5, 0, newZ-0.5),
    new THREE.Vector3(newX+0.5, 2, newZ+0.5)
  );
  let blocked = false;
  for(const box of colliders){
    if(box.intersectsBox(playerBox)){ blocked=true; break; }
  }
  if(!blocked){
    player.x=newX; player.z=newZ;
  }

  // Jumping & gravity
  if(isJumping || !isGrounded){
    player.y += velocityY;
    velocityY -= gravity;
    if(player.y <= 0){ player.y=0; velocityY=0; isJumping=false; isGrounded=true; }
    else{ isGrounded=false; }
  }

  player.model.position.set(player.x, player.y, player.z);
  if(dx!==0||dz!==0){ player.facing=Math.atan2(dx,dz); player.model.rotation.y=player.facing; }

  updateCamera(player);
  renderer.render(scene, camera);
}
animate();

// ====== Handle Resize ======
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
