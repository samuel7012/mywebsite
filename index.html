<html lang="en">
<head>
<meta charset="UTF-8">
<title>Stickman :P</title>
<style>
body { margin: 0; overflow: hidden; background: #111; }
#info {
  position: absolute; top: 10px; left: 10px;
  color: #fff; background: rgba(0,0,0,0.5);
  padding: 8px; border-radius: 5px; font-family: sans-serif;
}
#bottom-bar {
  position: fixed;
  left: 0; right: 0; bottom: 0;
  height: 60px;
  background: rgba(40,40,40,0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 99;
  gap: 24px;
}
#npc-btn, #monster-btn {
  background: #2e8bff;
  color: #fff;
  border: none;
  border-radius: 8px;
  padding: 13px 24px;
  font-size: 17px;
  cursor: pointer;
  transition: background 0.2s;
  box-shadow: 0 2px 8px #0005;
}
#npc-btn:hover, #monster-btn:hover {
  background: #1768c9;
}
</style>
</head>
<body>
<div id="info" style="width:98%; height:11%;">
  <marquee direction="right">
    <span class="flashEm">
      <b>W</b>/<b>A</b>/<b>S</b>/<b>D</b> to move |
      Hold <b>Shift</b> to run, <b>Space</b> to jump |
      Arrow keys to rotate/zoom camera |
      Stickman single-player demo
    </span>
  </marquee>
</div>
<div id="bottom-bar">
  <button id="npc-btn">Spawn NPC</button>
  <button id="monster-btn">Spawn Monster</button>
</div>

<style>
.flashEm {
  animation: flashItalic 1s infinite steps(1, start);
}
@keyframes flashItalic {
  0%, 100% { font-style: normal; }
  50% { font-style: italic; }
}
</style>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// ===== Scene setup =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Ground
const groundGeometry = new THREE.PlaneGeometry(60, 60);
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x696969 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// ===== Stickman factory =====
function createStickman(color=0xffffff) {
  const stickman = new THREE.Group();
  const stickMat = new THREE.MeshStandardMaterial({color: 0x181818});
  const headMat = new THREE.MeshStandardMaterial({color: color});

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 32, 32), headMat);
  head.position.y = 2.25;
  stickman.add(head);

  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.95, 20), stickMat);
  body.position.y = 1.5;
  stickman.add(body);

  function addLimb(rootPos, upperLen, lowerLen) {
    const root = new THREE.Group();
    root.position.copy(rootPos);
    stickman.add(root);

    const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, upperLen, 14), stickMat);
    upper.position.y = -upperLen/2;
    root.add(upper);

    const joint = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 10), stickMat);
    joint.position.y = -upperLen;
    root.add(joint);

    const lower = new THREE.Group();
    lower.position.y = -upperLen;
    const lowerMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, lowerLen, 12), stickMat);
    lowerMesh.position.y = -lowerLen/2;
    lower.add(lowerMesh);

    const end = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 8), stickMat);
    end.position.y = -lowerLen;
    lower.add(end);

    root.add(lower);
    return {root, lower, joint};
  }

  const leftArm = addLimb(new THREE.Vector3(-0.19, 1.9, 0), 0.49, 0.42);
  const rightArm = addLimb(new THREE.Vector3(0.19, 1.9, 0), 0.49, 0.42);
  const leftLeg = addLimb(new THREE.Vector3(-0.07, 0.99, 0), 0.58, 0.49);
  const rightLeg = addLimb(new THREE.Vector3(0.07, 0.99, 0), 0.58, 0.49);

  return {
    model: stickman,
    head,
    leftArm: leftArm.root, rightArm: rightArm.root,
    leftForearm: leftArm.lower, rightForearm: rightArm.lower,
    leftLeg: leftLeg.root, rightLeg: rightLeg.root,
    leftShin: leftLeg.lower, rightShin: rightLeg.lower,
    // For handle mapping
    leftArmJoint: leftArm.joint, rightArmJoint: rightArm.joint,
    leftLegJoint: leftLeg.joint, rightLegJoint: rightLeg.joint,
    leftForearmJoint: leftArm.lower, rightForearmJoint: rightArm.lower,
    leftShinJoint: leftLeg.lower, rightShinJoint: rightLeg.lower
  };
}

// ===== Player setup =====
const player = createStickman(0xffffff);
scene.add(player.model);
player.x = 0; player.y = 0; player.z = 0;
player.facing = 0;
player.walkCycle = 0;
player.state = "idle";

// ===== NPC management + Limb Handles =====
let npcs = [];
let npcActiveIdx = -1; // -1 means no npc selected
let npcDrag = false;
let dragOffset = {x:0, z:0};
let npcControlMode = false;

const handleMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444 });
function createHandleMesh() {
  return new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), handleMaterial);
}

function addLimbHandles(npc) {
  const handles = [];
  function makeHandle(joint, parentModel, label) {
    const mesh = createHandleMesh();
    mesh.visible = false;
    mesh.userData.label = label;
    parentModel.add(mesh);
    handles.push({mesh, joint, parentModel, label});
  }
  makeHandle(npc.leftArm, npc.model, "leftArm");
  makeHandle(npc.rightArm, npc.model, "rightArm");
  makeHandle(npc.leftLeg, npc.model, "leftLeg");
  makeHandle(npc.rightLeg, npc.model, "rightLeg");
  makeHandle(npc.leftForearm, npc.leftArm, "leftForearm");
  makeHandle(npc.rightForearm, npc.rightArm, "rightForearm");
  makeHandle(npc.leftShin, npc.leftLeg, "leftShin");
  makeHandle(npc.rightShin, npc.rightLeg, "rightShin");
  npc.limbHandles = handles;
}
function showHandles(npc, visible) {
  if (npc.limbHandles) {
    npc.limbHandles.forEach(h => h.mesh.visible = visible);
  }
}
function updateHandlePositions(npc) {
  if (!npc.limbHandles) return;
  npc.limbHandles.forEach(h => {
    let worldPos = new THREE.Vector3();
    h.joint.getWorldPosition(worldPos);
    h.parentModel.worldToLocal(worldPos);
    h.mesh.position.copy(worldPos);
  });
}

// Spawn NPC button
document.getElementById('npc-btn').onclick = function() {
  const npc = createStickman(0xffdd22);
  npc.x = Math.random()*6-3;
  npc.z = Math.random()*6-3;
  npc.y = 0;
  npc.facing = 0;
  npc.walkCycle = 0;
  npc.state = "idle";
  scene.add(npc.model);
  npc.model.position.set(npc.x, npc.y, npc.z);
  npcs.push(npc);
  npcActiveIdx = npcs.length-1;
  npcControlMode = true;
  addLimbHandles(npc);
  showHandles(npc, true);
  showNpcControlHint();
};

// Control hint
function showNpcControlHint() {
  if (!document.getElementById("npc-hint")) {
    let hint = document.createElement("div");
    hint.id = "npc-hint";
    hint.innerHTML = 'Press <b>E</b> to control NPC (drag with mouse, drag red dots to move limbs)';
    hint.style.position = "fixed";
    hint.style.bottom = "70px";
    hint.style.left = "50%";
    hint.style.transform = "translateX(-50%)";
    hint.style.background = "rgba(0,0,0,0.7)";
    hint.style.color = "#ffe";
    hint.style.padding = "9px 20px";
    hint.style.borderRadius = "7px";
    hint.style.fontFamily = "sans-serif";
    hint.style.fontSize = "17px";
    hint.style.zIndex = "100";
    document.body.appendChild(hint);
    setTimeout(() => { if(hint.parentNode) hint.parentNode.removeChild(hint); }, 3700);
  }
}

// NPC activation by E
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'e') {
    if (npcs.length > 0) {
      if (npcActiveIdx >= 0) showHandles(npcs[npcActiveIdx], false);
      npcActiveIdx = (npcActiveIdx+1)%npcs.length;
      npcControlMode = true;
      showHandles(npcs[npcActiveIdx], true);
      showNpcControlHint();
    }
  }
});

// NPC drag controls
renderer.domElement.addEventListener('mousedown', (e)=>{
  let handleClicked = false;
  if(npcControlMode && npcActiveIdx>=0) {
    let npc = npcs[npcActiveIdx];
    updateHandlePositions(npc);
    let rect = renderer.domElement.getBoundingClientRect();
    let mouse = {
      x: ((e.clientX-rect.left)/rect.width)*2-1,
      y: -((e.clientY-rect.top)/rect.height)*2+1
    };
    let raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    let objects = npc.limbHandles.map(h=>h.mesh).filter(m=>m.visible);
    let intersects = raycaster.intersectObjects(objects);
    if(intersects.length) {
      handleClicked = true;
      limbDrag.active = true;
      limbDrag.npc = npc;
      limbDrag.handle = npc.limbHandles.find(h=>h.mesh === intersects[0].object);
      limbDrag.startX = e.clientX;
      limbDrag.startRot = limbDrag.handle.joint.rotation.y;
      return;
    }
  }
  if(npcControlMode && npcActiveIdx>=0 && !handleClicked){
    npcDrag = true;
    let npc = npcs[npcActiveIdx];
    let rect = renderer.domElement.getBoundingClientRect();
    let mouse = {
      x: ((e.clientX-rect.left)/rect.width)*2-1,
      y: -((e.clientY-rect.top)/rect.height)*2+1
    };
    let raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    let intersects = raycaster.intersectObject(ground);
    if(intersects.length){
      dragOffset.x = npc.x - intersects[0].point.x;
      dragOffset.z = npc.z - intersects[0].point.z;
    }
  }
});

renderer.domElement.addEventListener('mouseup', ()=>{
  npcDrag=false;
  limbDrag.active=false;
});

renderer.domElement.addEventListener('mousemove', (e)=>{
  if(limbDrag.active && limbDrag.npc && limbDrag.handle){
    let deltaX = e.clientX - limbDrag.startX;
    let newRot = limbDrag.startRot + deltaX * 0.01;
    newRot = Math.max(-2.5, Math.min(2.5, newRot));
    limbDrag.handle.joint.rotation.y = newRot;
    return;
  }
  if(npcDrag && npcActiveIdx>=0){
    let npc = npcs[npcActiveIdx];
    let rect = renderer.domElement.getBoundingClientRect();
    let mouse = {
      x: ((e.clientX-rect.left)/rect.width)*2-1,
      y: -((e.clientY-rect.top)/rect.height)*2+1
    };
    let raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    let intersects = raycaster.intersectObject(ground);
    if(intersects.length){
      npc.x = intersects[0].point.x + dragOffset.x;
      npc.z = intersects[0].point.z + dragOffset.z;
      npc.model.position.set(npc.x, npc.y, npc.z);
    }
  }
});

const limbDrag = {
  active: false,
  npc: null,
  handle: null,
  startX: 0,
  startRot: 0
};

// ===== Monster Management =====
const monsters = [];

// Dinosaur
function createDinosaur() {
  const group = new THREE.Group();
  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.5, 1.7, 16), new THREE.MeshStandardMaterial({color:0x228833}));
  body.position.y = 1.1; group.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.32, 20, 14), new THREE.MeshStandardMaterial({color:0x44cc66}));
  head.position.set(0, 1.7, 0.45); group.add(head);
  const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.15, 1.2, 8), new THREE.MeshStandardMaterial({color:0x228833}));
  tail.position.set(0, 1.05, -0.8); tail.rotation.x = Math.PI/2.4; group.add(tail);
  function leg(x,z) {
    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.13, 0.7, 10), new THREE.MeshStandardMaterial({color:0x228833}));
    leg.position.set(x, 0.4, z); group.add(leg);
  }
  leg(-0.23, 0.25); leg(0.23, 0.25); leg(-0.23, -0.22); leg(0.23, -0.22);
  function arm(x,z) {
    const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.06, 0.35, 8), new THREE.MeshStandardMaterial({color:0x44cc66}));
    arm.position.set(x, 1.2, z); arm.rotation.z = Math.PI/4 * (x>0?1:-1); group.add(arm);
  }
  arm(-0.18, 0.36); arm(0.18, 0.36);
  return group;
}

// Loch Ness Monster
function createLochNess() {
  const group = new THREE.Group();
  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.24,0.31,1.9,12), new THREE.MeshStandardMaterial({color:0x2e6687}));
  body.position.y = 0.55; group.add(body);
  const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.13,0.7,10), new THREE.MeshStandardMaterial({color:0x69cbe8}));
  neck.position.set(0,1.4,0.45); neck.rotation.x = -Math.PI/7; group.add(neck);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.16, 12, 8), new THREE.MeshStandardMaterial({color:0x69cbe8}));
  head.position.set(0,1.75,0.8); group.add(head);
  const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.12,0.8,7), new THREE.MeshStandardMaterial({color:0x2e6687}));
  tail.position.set(0,0.5,-0.85); tail.rotation.x = Math.PI/4.5; group.add(tail);
  function fin(x,z) {
    const fin = new THREE.Mesh(new THREE.SphereGeometry(0.11,8,7,0,Math.PI), new THREE.MeshStandardMaterial({color:0x69cbe8}));
    fin.position.set(x,0.2,z); group.add(fin);
  }
  fin(-0.15,0.2); fin(0.15,0.2); fin(-0.13,-0.22); fin(0.13,-0.22);
  return group;
}

// Spider
function createSpider() {
  const group = new THREE.Group();
  const body = new THREE.Mesh(new THREE.SphereGeometry(0.22, 16, 10), new THREE.MeshStandardMaterial({color:0x222222}));
  body.position.y = 0.22; group.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.13, 10, 7), new THREE.MeshStandardMaterial({color:0x333333}));
  head.position.set(0, 0.22, 0.19); group.add(head);
  function leg(angle) {
    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.027, 0.5, 7), new THREE.MeshStandardMaterial({color:0x222222}));
    leg.position.set(Math.sin(angle)*0.19, 0.17, Math.cos(angle)*0.19);
    leg.rotation.z = Math.PI/2;
    leg.rotation.y = angle;
    group.add(leg);
  }
  for(let i=0;i<8;i++) leg(i*Math.PI/4);
  return group;
}

// Slime
function createSlime() {
  const group = new THREE.Group();
  const body = new THREE.Mesh(new THREE.SphereGeometry(0.32, 20, 14), new THREE.MeshStandardMaterial({color:0x00ff99, transparent:true, opacity:0.7}));
  body.position.y = 0.32; group.add(body);
  const face = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 7), new THREE.MeshStandardMaterial({color:0x005544}));
  face.position.set(0, 0.32, 0.21); group.add(face);
  return group;
}

// Ghost
function createGhost() {
  const group = new THREE.Group();
  const body = new THREE.Mesh(new THREE.SphereGeometry(0.22, 20, 14), new THREE.MeshStandardMaterial({color:0xffffff, transparent:true, opacity:0.6}));
  body.position.y = 0.22; group.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.15, 10, 8), new THREE.MeshStandardMaterial({color:0xffffff, transparent:true, opacity:0.7}));
  head.position.set(0, 0.37, 0); group.add(head);
  const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 8), new THREE.MeshStandardMaterial({color:0x222222}));
  eye1.position.set(-0.04,0.42,0.11); group.add(eye1);
  const eye2 = eye1.clone(); eye2.position.x = 0.04; group.add(eye2);
  return group;
}

// Dragon
function createDragon() {
  const group = new THREE.Group();
  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.26, 0.34, 1.5, 18), new THREE.MeshStandardMaterial({color:0x991111}));
  body.position.y = 1.0; group.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.24, 15, 10), new THREE.MeshStandardMaterial({color:0xff3333}));
  head.position.set(0, 1.6, 0.3); group.add(head);
  const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.13, 1.2, 10), new THREE.MeshStandardMaterial({color:0x991111}));
  tail.position.set(0, 1.0, -0.8); tail.rotation.x = Math.PI/2.6; group.add(tail);
  const wingMat = new THREE.MeshStandardMaterial({color:0xdd2222, side:THREE.DoubleSide});
  function wing(sign) {
    const wing = new THREE.Mesh(new THREE.PlaneGeometry(0.7,0.3), wingMat);
    wing.position.set(sign*0.33, 1.4, 0.1);
    wing.rotation.z = sign*-0.7;
    group.add(wing);
  }
  wing(1); wing(-1);
  function leg(x,z) {
    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.6, 8), new THREE.MeshStandardMaterial({color:0x991111}));
    leg.position.set(x, 0.4, z); group.add(leg);
  }
  leg(-0.17, 0.24); leg(0.17, 0.24); leg(-0.17, -0.16); leg(0.17, -0.16);
  return group;
}

const monsterTypes = [
  { label: "Dinosaur", fn: createDinosaur },
  { label: "Loch Ness Monster", fn: createLochNess },
  { label: "Spider", fn: createSpider },
  { label: "Slime", fn: createSlime },
  { label: "Ghost", fn: createGhost },
  { label: "Dragon", fn: createDragon }
];

document.getElementById('monster-btn').onclick = function() {
  const idx = Math.floor(Math.random() * monsterTypes.length);
  const monster = monsterTypes[idx].fn();
  monster.position.set(Math.random()*8-4, 0, Math.random()*8-4);
  scene.add(monster);
  monsters.push(monster);
  showMonsterHint(monsterTypes[idx].label);
};
function showMonsterHint(label) {
  if (!document.getElementById("monster-hint")) {
    let hint = document.createElement("div");
    hint.id = "monster-hint";
    hint.innerHTML = label + " spawned!";
    hint.style.position = "fixed";
    hint.style.bottom = "70px";
    hint.style.left = "50%";
    hint.style.transform = "translateX(-50%)";
    hint.style.background = "rgba(0,0,0,0.7)";
    hint.style.color = "#ffe";
    hint.style.padding = "9px 20px";
    hint.style.borderRadius = "7px";
    hint.style.fontFamily = "sans-serif";
    hint.style.fontSize = "17px";
    hint.style.zIndex = "100";
    document.body.appendChild(hint);
    setTimeout(() => { if(hint.parentNode) hint.parentNode.removeChild(hint); }, 2000);
  }
}

// ===== Controls =====
let moveForward = false,
    moveBackward = false,
    moveLeft = false,
    moveRight = false;
let isRunning = false;
let isJumping = false;
let isGrounded = true;
let velocityY = 0;

const walkSpeed   = 0.08;
const runSpeed    = 0.16;
const jumpStrength = 0.24;
const gravity      = 0.012;

// ===== Camera orbit (Arrow keys only) =====
let azimuth = 0, polar = Math.PI/5, radius = 8;
const minPolar = 0.1, maxPolar = Math.PI/2-0.05;
const minRadius = 2, maxRadius = 30;
const camAzimuthStep = 0.06;
const camPolarStep = 0.04;
const camRadiusStep = 0.5;

window.addEventListener('keydown', (e) => {
  switch (e.key) {
    case 's': moveForward = true; break;
    case 'w': moveBackward = true; break;
    case 'a': moveLeft = true; break;
    case 'd': moveRight = true; break;
    case 'Shift': isRunning = true; break;
    case 'ArrowLeft':
      azimuth -= camAzimuthStep;
      break;
    case 'ArrowRight':
      azimuth += camAzimuthStep;
      break;
    case 'ArrowUp':
      polar -= camPolarStep;
      polar = Math.max(minPolar, Math.min(maxPolar, polar));
      break;
    case 'ArrowDown':
      polar += camPolarStep;
      polar = Math.max(minPolar, Math.min(maxPolar, polar));
      break;
    case '+': case '=':
      radius -= camRadiusStep;
      radius = Math.max(minRadius, Math.min(maxRadius, radius));
      break;
    case '-':
      radius += camRadiusStep;
      radius = Math.max(minRadius, Math.min(maxRadius, radius));
      break;
    case ' ':
      if (isGrounded && !isJumping) {
        isJumping = true;
        velocityY = jumpStrength;
      }
      break;
  }
});

window.addEventListener('keyup', (e) => {
  switch (e.key) {
    case 's': moveForward = false; break;
    case 'w': moveBackward = false; break;
    case 'a': moveLeft = false; break;
    case 'd': moveRight = false; break;
    case 'Shift': isRunning = false; break;
  }
});

function updateCamera(target){
  let camX=target.x+radius*Math.sin(polar)*Math.sin(azimuth);
  let camY=target.y+radius*Math.cos(polar)+1;
  let camZ=target.z+radius*Math.sin(polar)*Math.cos(azimuth);
  camera.position.set(camX, camY, camZ);
  camera.lookAt(target.x, target.y+1.4, target.z);
}

// ===== Stickman animation =====
function animateStickman(player, dt){
  let t=player.walkCycle;
  let la=player.leftArm, ra=player.rightArm;
  let lfa=player.leftForearm, rfa=player.rightForearm;
  let ll=player.leftLeg, rl=player.rightLeg;
  let ls=player.leftShin, rs=player.rightShin;
  let state=player.state;

  if(state==="idle"){
    la.rotation.x=ra.rotation.x=lfa.rotation.x=rfa.rotation.x=0;
    ll.rotation.x=rl.rotation.x=ls.rotation.x=rs.rotation.x=0;
  } else if(state==="walk"){
    let f=5, aa=0.65, al=0.7, sa=0.47, ph=t*f;
    la.rotation.x=Math.sin(ph)*aa;
    ra.rotation.x=Math.sin(ph+Math.PI)*aa;
    ll.rotation.x=Math.sin(ph)*al;
    rl.rotation.x=Math.sin(ph+Math.PI)*al;
    ls.rotation.x=Math.max(0,-Math.sin(ph+Math.PI/4))*sa;
    rs.rotation.x=Math.max(0,-Math.sin(ph+Math.PI/4+Math.PI))*sa;
    player.walkCycle += dt*(isRunning?1.04:1);
  } else if(state==="run"){
    let f=9.5, aa=1.6, al=1.8, sa=1.35, ph=t*f;
    la.rotation.x=Math.sin(ph)*aa*0.6;
    ra.rotation.x=Math.sin(ph+Math.PI)*aa*0.6;
    lfa.rotation.x=Math.abs(Math.sin(ph))*0.9-1.1;
    rfa.rotation.x=Math.abs(Math.sin(ph+Math.PI))*0.9-1.1;
    ll.rotation.x=Math.sin(ph)*al;
    rl.rotation.x=Math.sin(ph+Math.PI)*al;
    ls.rotation.x=Math.max(0,-Math.sin(ph+Math.PI/6))*sa +0.13*Math.abs(Math.sin(ph));
    rs.rotation.x=Math.max(0,-Math.sin(ph+Math.PI/6+Math.PI))*sa +0.13*Math.abs(Math.sin(ph+Math.PI));
    player.walkCycle += dt*1.3;
  } else if(state==="jump"){
    la.rotation.x=ra.rotation.x=-1.15;
    lfa.rotation.x=rfa.rotation.x=-0.42;
    ll.rotation.x=rl.rotation.x=0.88;
    ls.rotation.x=rs.rotation.x=0.8;
    player.walkCycle += dt*0.6;
  }
}

// ===== Main loop =====
let prevTime = performance.now();
function animate(){
  requestAnimationFrame(animate);
  let time = performance.now();
  let dt = Math.min((time-prevTime)/1000,0.05);
  prevTime = time;

  let dx=0,dz=0;
  let speed = isRunning ? runSpeed : walkSpeed;
  if(moveForward){dx+=Math.sin(azimuth)*speed; dz+=Math.cos(azimuth)*speed;}
  if(moveBackward){dx-=Math.sin(azimuth)*speed; dz-=Math.cos(azimuth)*speed;}
  if(moveLeft){dx+=Math.sin(azimuth-Math.PI/2)*speed; dz+=Math.cos(azimuth-Math.PI/2)*speed;}
  if(moveRight){dx+=Math.sin(azimuth+Math.PI/2)*speed; dz+=Math.cos(azimuth+Math.PI/2)*speed;}

  player.x += dx; player.z += dz;
  if(isJumping||!isGrounded){
    player.y += velocityY;
    velocityY -= gravity;
    if(player.y<=0){player.y=0; velocityY=0; isJumping=false; isGrounded=true;}
    else{isGrounded=false;}
  }

  player.model.position.set(player.x,player.y,player.z);
  if(dx!==0||dz!==0){player.facing=Math.atan2(dx,dz); player.model.rotation.y=player.facing;}

  let state="idle";
  if(isJumping||!isGrounded) state="jump";
  else if(dx!==0||dz!==0) state=isRunning?"run":"walk";
  player.state=state;
  animateStickman(player, dt);

  for(let i=0;i<npcs.length;i++){
    let npc = npcs[i];
    if(npcActiveIdx===i && npcDrag){
      npc.state = "jump";
    } else {
      npc.state = "idle";
    }
    animateStickman(npc, dt);
    npc.model.position.set(npc.x, npc.y, npc.z);
    if(npc.limbHandles) updateHandlePositions(npc);
  }

  for(let i=0;i<npcs.length;i++){
    if(npcs[i].limbHandles) showHandles(npcs[i], i === npcActiveIdx && npcControlMode);
  }

  updateCamera(player);
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
