<html lang="en">
<head>
<meta charset="UTF-8">
  <title>BROSKI STOP</title>
<style>
body { margin: 0; overflow: hidden; }
#info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; }
</style>
</head>
<body>
<div id="info">
<b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
<b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
<b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 8, 12);
camera.lookAt(5, 5, 5);
let cameraMode = 1; // 1: third-person, 2: first-person, 3: top-down
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Original Ground (Visual only)
const groundGeometry = new THREE.PlaneGeometry(100, 100);
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// Endless Platforms (Minimal Addition)
const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
const platforms = [];

for (let i = -10; i <= 10; i++) {
  for (let j = -10; j <= 10; j++) {
    const tile = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 2), platformMaterial);
    tile.position.set(i * 2, 5, j * 2);
    tile.userData = {
      width: 2,
      height: 0.1,
      depth: 2,
      solid: true
    };
    scene.add(tile);
    platforms.push(tile);
  }
}

// Create a simple wall block
const wallGeometry = new THREE.BoxGeometry(2, 4, 0.5); // width, height, depth
const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
const wall = new THREE.Mesh(wallGeometry, wallMaterial);

// Position the wall somewhere in the scene
wall.position.set(5, 2, 0); // x, y (half height), z
scene.add(wall);

// Stickman group (perfect stickman proportions and joints)
const stickman = new THREE.Group();

// Materials
const stickMat = new THREE.MeshStandardMaterial({color: 0x181818});
const headMat = new THREE.MeshStandardMaterial({color: 0xffffff});

// Head (proportionally large)
const head = new THREE.Mesh(
new THREE.SphereGeometry(0.28, 32, 32),
headMat
);
head.position.y = 2.25;
stickman.add(head);

// Body (spine)
const body = new THREE.Mesh(
new THREE.CylinderGeometry(0.06, 0.06, 0.95, 20),
stickMat
);
body.position.y = 1.5;
stickman.add(body);

// Shoulders (joint)
const shoulders = new THREE.Mesh(
new THREE.SphereGeometry(0.09, 20, 16),
stickMat
);
shoulders.position.y = 1.98;
stickman.add(shoulders);

// Hips (joint)
const hips = new THREE.Mesh(
new THREE.SphereGeometry(0.085, 18, 12),
stickMat
);
hips.position.y = 1.02;
stickman.add(hips);

// Arms and Legs as groups for animation
// LEFT ARM
const leftArm = new THREE.Group();
leftArm.position.set(-0.19, 1.9, 0);
stickman.add(leftArm);

// Upper arm
const upperArmL = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14),
stickMat
);
upperArmL.position.y = -0.245;
leftArm.add(upperArmL);

// Elbow
const elbowL = new THREE.Mesh(
new THREE.SphereGeometry(0.06, 12, 10),
stickMat
);
elbowL.position.y = -0.49;
leftArm.add(elbowL);

// Forearm
const leftForearm = new THREE.Group();
leftForearm.position.y = -0.49;
const lowerArmL = new THREE.Mesh(
new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12),
stickMat
);
lowerArmL.position.y = -0.21;
leftForearm.add(lowerArmL);

// Wrist/Hand
const handL = new THREE.Mesh(
new THREE.SphereGeometry(0.045, 10, 8),
stickMat
);
handL.position.y = -0.42;
leftForearm.add(handL);

leftArm.add(leftForearm);

// RIGHT ARM
const rightArm = new THREE.Group();
rightArm.position.set(0.19, 1.9, 0);
stickman.add(rightArm);

const upperArmR = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14),
stickMat
);
upperArmR.position.y = -0.245;
rightArm.add(upperArmR);

const elbowR = new THREE.Mesh(
new THREE.SphereGeometry(0.06, 12, 10),
stickMat
);
elbowR.position.y = -0.49;
rightArm.add(elbowR);

const rightForearm = new THREE.Group();
rightForearm.position.y = -0.49;
const lowerArmR = new THREE.Mesh(
new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12),
stickMat
);
lowerArmR.position.y = -0.21;
rightForearm.add(lowerArmR);

const handR = new THREE.Mesh(
new THREE.SphereGeometry(0.045, 10, 8),
stickMat
);
handR.position.y = -0.42;
rightForearm.add(handR);

rightArm.add(rightForearm);

// LEFT LEG
const leftLeg = new THREE.Group();
leftLeg.position.set(-0.07, 0.99, 0);
stickman.add(leftLeg);

// Thigh
const upperLegL = new THREE.Mesh(
new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14),
stickMat
);
upperLegL.position.y = -0.29;
leftLeg.add(upperLegL);

// Knee
const kneeL = new THREE.Mesh(
new THREE.SphereGeometry(0.07, 12, 8),
stickMat
);
kneeL.position.y = -0.58;
leftLeg.add(kneeL);

// Shin
const leftShin = new THREE.Group();
leftShin.position.y = -0.58;
const lowerLegL = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12),
stickMat
);
lowerLegL.position.y = -0.245;
leftShin.add(lowerLegL);

// Foot
const footL = new THREE.Mesh(
new THREE.SphereGeometry(0.05, 10, 8),
stickMat
);
footL.position.y = -0.49;
leftShin.add(footL);

leftLeg.add(leftShin);

// RIGHT LEG
const rightLeg = new THREE.Group();
rightLeg.position.set(0.07, 0.99, 0);
stickman.add(rightLeg);

// Thigh
const upperLegR = new THREE.Mesh(
new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14),
stickMat
);
upperLegR.position.y = -0.29;
rightLeg.add(upperLegR);

// Knee
const kneeR = new THREE.Mesh(
new THREE.SphereGeometry(0.07, 12, 8),
stickMat
);
kneeR.position.y = -0.58;
rightLeg.add(kneeR);

// Shin
const rightShin = new THREE.Group();
rightShin.position.y = -0.58;
const lowerLegR = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12),
stickMat
);
lowerLegR.position.y = -0.245;
rightShin.add(lowerLegR);

// Foot
const footR = new THREE.Mesh(
new THREE.SphereGeometry(0.05, 10, 8),
stickMat
);
footR.position.y = -0.49;
rightShin.add(footR);

rightLeg.add(rightShin);

scene.add(stickman);

// Movement state
let moveBackward = false, moveForward = false, moveLeft = false, moveRight = false;
let isRunning = false;
let isJumping = false;
let isGrounded = true;
let velocityY = 0;
const walkSpeed = 0.08;
const runSpeed = 0.16;
const jumpStrength = 0.24;
const gravity = 0.012;
let walkCycle = 0; // for gait animation

window.addEventListener('keydown', function(e){
switch(e.key) {
case 'w': moveBackward = true; break;
case 's': moveForward = true; break;
case 'a': moveLeft = true; break;
case 'd': moveRight = true; break;
case 'Shift': isRunning = true; break;
case ' ': 
if(isGrounded) {
velocityY = jumpStrength;
isJumping = true;
isGrounded = false;
}
break;
case '1': cameraMode = 1; break;
case '2': cameraMode = 2; break;
case '3': cameraMode = 3; break;
}
});

window.addEventListener('keyup', function(e){
switch(e.key) {
case 'w': moveBackward = false; break;
case 's': moveForward = false; break;
case 'a': moveLeft = false; break;
case 'd': moveRight = false; break;
case 'Shift': isRunning = false; break;
}
});

// Mouse control
let mouseX = 0;
let mouseY = 0;
let isPointerLocked = false;

function onMouseMove(e) {
if(!isPointerLocked) return;
mouseX += e.movementX * 0.0025;
mouseY += e.movementY * 0.0025;
mouseY = Math.min(Math.max(mouseY, -Math.PI/3), Math.PI/3);
}

document.body.addEventListener('click', () => {
if(!isPointerLocked) {
document.body.requestPointerLock();
}
});

document.addEventListener('pointerlockchange', () => {
isPointerLocked = document.pointerLockElement === document.body;
});

document.addEventListener('mousemove', onMouseMove);

// Raycaster for ground/platform detection
const raycaster = new THREE.Raycaster();
const downVector = new THREE.Vector3(0, -1, 0);

// Stickman base position and rotation
stickman.position.set(0, 5, 0);
stickman.rotation.y = 0;

function animate() {
// Movement vector
let moveX = 0;
let moveZ = 0;
if(moveForward) moveZ -= 1;
if(moveBackward) moveZ += 1;
if(moveLeft) moveX -= 1;
if(moveRight) moveX += 1;

const length = Math.sqrt(moveX*moveX + moveZ*moveZ);
if(length > 0) {
moveX /= length;
moveZ /= length;
}

// Determine speed
const speed = isRunning ? runSpeed : walkSpeed;

// Apply horizontal movement
stickman.position.x += moveX * speed;
stickman.position.z += moveZ * speed;

// Rotate stickman to face movement direction
if(length > 0) {
stickman.rotation.y = Math.atan2(moveX, moveZ);
}

// Gravity and vertical movement
velocityY -= gravity;
stickman.position.y += velocityY;

// Check platform collision under stickman
raycaster.set(stickman.position.clone().add(new THREE.Vector3(0, 0.2, 0)), downVector);
const intersects = raycaster.intersectObjects(platforms.concat([ground, wall]));
if(intersects.length > 0) {
const closest = intersects[0];
const platformY = closest.point.y;
if(stickman.position.y < platformY + 0.5) {
stickman.position.y = platformY + 0.5;
velocityY = 0;
isGrounded = true;
isJumping = false;
}
} else {
isGrounded = false;
}

// Animate gait cycle
if(length > 0) {
walkCycle += speed * 0.1;
} else {
walkCycle = 0;
}

const swing = Math.sin(walkCycle * 8) * 0.7;
const kneeBend = Math.cos(walkCycle * 8) * 0.5;

// Arms swing opposite to legs
leftArm.rotation.x = swing;
rightArm.rotation.x = -swing;

// Forearms bend at elbow (opposite phase to upper arms)
leftForearm.rotation.x = -swing * 0.5;
rightForearm.rotation.x = swing * 0.5;

// Legs swing
leftLeg.rotation.x = -swing;
rightLeg.rotation.x = swing;

// Knees bend slightly
leftShin.rotation.x = Math.max(0, kneeBend);
rightShin.rotation.x = Math.max(0, -kneeBend);

// Camera control by mode
if(cameraMode === 1) { // third person
const offset = new THREE.Vector3(0, 3, 5);
offset.applyAxisAngle(new THREE.Vector3(0,1,0), stickman.rotation.y + mouseX);
camera.position.copy(stickman.position).add(offset);
camera.lookAt(stickman.position.clone().add(new THREE.Vector3(0, 2, 0)));
} else if(cameraMode === 2) { // first person
camera.position.copy(stickman.position).add(new THREE.Vector3(0, 2.3, 0));
camera.rotation.set(-mouseY, stickman.rotation.y + mouseX, 0);
} else { // top down
camera.position.set(stickman.position.x, 20, stickman.position.z);
camera.lookAt(stickman.position);
}

renderer.render(scene, camera);
requestAnimationFrame(animate);
}

animate();

window.addEventListener('resize', () => {
camera.aspect = window.innerWidth/window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
