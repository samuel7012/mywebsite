<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Just a Platformer with Waving Grass</title>
<style>
  body { margin: 0; overflow: hidden; }
  #info {
    position: absolute;
    top: 10px; left: 10px;
    color: #fff;
    background: rgba(0,0,0,0.5);
    padding: 8px;
    border-radius: 5px;
    font-family: sans-serif;
    user-select: none;
  }
</style>
</head>
<body>
<div id="info" style="display:none">
  <b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
  Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
  <b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
  <b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// Scene Setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);

let cameraMode = 1; // 1: third-person, 2: first-person, 3: top-down

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// --- Waving Grass Ground ---
// Large plane geometry subdivided for vertex displacement
const groundGeometry = new THREE.PlaneGeometry(100, 100, 100, 100);
groundGeometry.rotateX(-Math.PI/2);

// Vertex Shader for waving effect
const vertexShader = `
  uniform float time;
  varying vec2 vUv;
  void main() {
    vUv = uv;
    vec3 pos = position;
    float wave = sin(pos.x * 5.0 + time * 2.0) * 0.15 + cos(pos.z * 7.0 + time * 3.0) * 0.15;
    pos.y += wave;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
`;

// Fragment Shader for green gradient grass color
const fragmentShader = `
  varying vec2 vUv;
  void main() {
    vec3 color = mix(vec3(0.1, 0.3, 0.05), vec3(0.4, 0.8, 0.1), vUv.y);
    gl_FragColor = vec4(color, 1.0);
  }
`;

const uniforms = { time: { value: 0 } };

const groundMaterial = new THREE.ShaderMaterial({
  vertexShader,
  fragmentShader,
  uniforms,
  side: THREE.DoubleSide
});

const ground = new THREE.Mesh(groundGeometry, groundMaterial);
scene.add(ground);

// --- Stickman Model ---

const stickman = new THREE.Group();

// Materials
const stickMat = new THREE.MeshStandardMaterial({color: 0x181818});
const headMat = new THREE.MeshStandardMaterial({color: 0xffffff});

// Head
const head = new THREE.Mesh(
  new THREE.SphereGeometry(0.28, 32, 32),
  headMat
);
head.position.y = 2.25;
stickman.add(head);

// Body (spine)
const body = new THREE.Mesh(
  new THREE.CylinderGeometry(0.06, 0.06, 0.95, 20),
  stickMat
);
body.position.y = 1.5;
stickman.add(body);

// Shoulders
const shoulders = new THREE.Mesh(
  new THREE.SphereGeometry(0.09, 20, 16),
  stickMat
);
shoulders.position.y = 1.98;
stickman.add(shoulders);

// Hips
const hips = new THREE.Mesh(
  new THREE.SphereGeometry(0.085, 18, 12),
  stickMat
);
hips.position.y = 1.02;
stickman.add(hips);

// LEFT ARM
const leftArm = new THREE.Group();
leftArm.position.set(-0.19, 1.9, 0);
stickman.add(leftArm);

const upperArmL = new THREE.Mesh(
  new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14),
  stickMat
);
upperArmL.position.y = -0.245;
leftArm.add(upperArmL);

const elbowL = new THREE.Mesh(
  new THREE.SphereGeometry(0.06, 12, 10),
  stickMat
);
elbowL.position.y = -0.49;
leftArm.add(elbowL);

const leftForearm = new THREE.Group();
leftForearm.position.y = -0.49;
const lowerArmL = new THREE.Mesh(
  new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12),
  stickMat
);
lowerArmL.position.y = -0.21;
leftForearm.add(lowerArmL);

const handL = new THREE.Mesh(
  new THREE.SphereGeometry(0.045, 10, 8),
  stickMat
);
handL.position.y = -0.42;
leftForearm.add(handL);

leftArm.add(leftForearm);

// RIGHT ARM
const rightArm = new THREE.Group();
rightArm.position.set(0.19, 1.9, 0);
stickman.add(rightArm);

const upperArmR = new THREE.Mesh(
  new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14),
  stickMat
);
upperArmR.position.y = -0.245;
rightArm.add(upperArmR);

const elbowR = new THREE.Mesh(
  new THREE.SphereGeometry(0.06, 12, 10),
  stickMat
);
elbowR.position.y = -0.49;
rightArm.add(elbowR);

const rightForearm = new THREE.Group();
rightForearm.position.y = -0.49;
const lowerArmR = new THREE.Mesh(
  new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12),
  stickMat
);
lowerArmR.position.y = -0.21;
rightForearm.add(lowerArmR);

const handR = new THREE.Mesh(
  new THREE.SphereGeometry(0.045, 10, 8),
  stickMat
);
handR.position.y = -0.42;
rightForearm.add(handR);

rightArm.add(rightForearm);

// LEFT LEG
const leftLeg = new THREE.Group();
leftLeg.position.set(-0.07, 0.99, 0);
stickman.add(leftLeg);

const upperLegL = new THREE.Mesh(
  new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14),
  stickMat
);
upperLegL.position.y = -0.29;
leftLeg.add(upperLegL);

const kneeL = new THREE.Mesh(
  new THREE.SphereGeometry(0.07, 12, 8),
  stickMat
);
kneeL.position.y = -0.58;
leftLeg.add(kneeL);

const leftShin = new THREE.Group();
leftShin.position.y = -0.58;
const lowerLegL = new THREE.Mesh(
  new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12),
  stickMat
);
lowerLegL.position.y = -0.245;
leftShin.add(lowerLegL);

const footL = new THREE.Mesh(
  new THREE.SphereGeometry(0.05, 10, 8),
  stickMat
);
footL.position.y = -0.49;
leftShin.add(footL);

leftLeg.add(leftShin);

// RIGHT LEG
const rightLeg = new THREE.Group();
rightLeg.position.set(0.07, 0.99, 0);
stickman.add(rightLeg);

const upperLegR = new THREE.Mesh(
  new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14),
  stickMat
);
upperLegR.position.y = -0.29;
rightLeg.add(upperLegR);

const kneeR = new THREE.Mesh(
  new THREE.SphereGeometry(0.07, 12, 8),
  stickMat
);
kneeR.position.y = -0.58;
rightLeg.add(kneeR);

const rightShin = new THREE.Group();
rightShin.position.y = -0.58;
const lowerLegR = new THREE.Mesh(
  new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12),
  stickMat
);
lowerLegR.position.y = -0.245;
rightShin.add(lowerLegR);

const footR = new THREE.Mesh(
  new THREE.SphereGeometry(0.05, 10, 8),
  stickMat
);
footR.position.y = -0.49;
rightShin.add(footR);

rightLeg.add(rightShin);

scene.add(stickman);

// --- Movement State ---
let moveBackward = false, moveForward = false, moveLeft = false, moveRight = false;
let isRunning = false;
let isJumping = false;
let isGrounded = true;
let velocityY = 0;

const walkSpeed = 0.08;
const runSpeed = 0.16;
const jumpStrength = 0.24;
const gravity = 0.012;

let walkCycle = 0; // For gait animation

window.addEventListener('keydown', e => {
  switch(e.key.toLowerCase()) {
    case 'w': moveBackward = true; break;
    case 's': moveForward = true; break;
    case 'a': moveLeft = true; break;
    case 'd': moveRight = true; break;
    case 'shift': isRunning = true; break;
    case ' ': 
      if (isGrounded && !isJumping) {
        isJumping = true;
        velocityY = jumpStrength;
      }
      break;
    case '1': cameraMode = 1; break;
    case '2': cameraMode = 2; break;
    case '3': cameraMode = 3; break;
  }
});

window.addEventListener('keyup', e => {
  switch(e.key.toLowerCase()) {
    case 'w': moveBackward = false; break;
    case 's': moveForward = false; break;
    case 'a': moveLeft = false; break;
    case 'd': moveRight = false; break;
    case 'shift': isRunning = false; break;
  }
});

// Mouse controls for camera orbit
let azimuth = 0;
let polar = Math.PI / 5;
let isMouseDown = false;
let lastMouseX, lastMouseY;

renderer.domElement.addEventListener('mousedown', e => {
  isMouseDown = true;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
});
renderer.domElement.addEventListener('mouseup', e => {
  isMouseDown = false;
});
renderer.domElement.addEventListener('mouseout', e => {
  isMouseDown = false;
});
renderer.domElement.addEventListener('mousemove', e => {
  if (isMouseDown) {
    const dx = e.clientX - lastMouseX;
    const dy = e.clientY - lastMouseY;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;

    azimuth -= dx * 0.005;
    polar -= dy * 0.005;
    polar = Math.min(Math.max(0.1, polar), Math.PI / 2.1);
  }
});

// Mouse wheel zoom
let zoom = 8;
window.addEventListener('wheel', e => {
  zoom += e.deltaY * 0.01;
  zoom = Math.min(Math.max(2, zoom), 20);
});

// Camera update function
function updateCamera() {
  if (cameraMode === 1) {
    // Third-person camera behind and above stickman
    const offsetY = 3;
    const offsetZ = zoom;
    const x = stickman.position.x;
    const y = stickman.position.y;
    const z = stickman.position.z;

    camera.position.x = x + Math.sin(azimuth) * offsetZ;
    camera.position.z = z + Math.cos(azimuth) * offsetZ;
    camera.position.y = y + offsetY + Math.sin(polar) * offsetZ;

    camera.lookAt(x, y + 1.5, z);
  } else if (cameraMode === 2) {
    // First-person camera from head
    const headWorldPos = new THREE.Vector3();
    head.getWorldPosition(headWorldPos);

    const dir = new THREE.Vector3(
      Math.sin(azimuth),
      0,
      Math.cos(azimuth)
    );
    dir.y = Math.sin(polar);
    dir.normalize();

    camera.position.copy(headWorldPos);
    camera.position.y += 0.1;
    const lookAtPos = headWorldPos.clone().add(dir.multiplyScalar(10));
    camera.lookAt(lookAtPos);
  } else {
    // Top-down camera
    camera.position.set(stickman.position.x, 15, stickman.position.z);
    camera.lookAt(stickman.position.x, 0, stickman.position.z);
  }
}

// Animate walking gait
function animateGait(timeDelta) {
  const speed = (moveForward || moveBackward || moveLeft || moveRight) ? (isRunning ? runSpeed : walkSpeed) : 0;
  if (speed > 0) {
    walkCycle += speed * 10;
  } else {
    walkCycle *= 0.8; // slow down when not moving
  }

  const swingAmount = 0.7;
  leftArm.rotation.x = Math.sin(walkCycle) * swingAmount;
  rightArm.rotation.x = -Math.sin(walkCycle) * swingAmount;
  leftLeg.rotation.x = -Math.sin(walkCycle) * swingAmount;
  rightLeg.rotation.x = Math.sin(walkCycle) * swingAmount;

  leftForearm.rotation.x = Math.abs(Math.sin(walkCycle)) * 0.5;
  rightForearm.rotation.x = Math.abs(Math.sin(walkCycle)) * 0.5;
  leftShin.rotation.x = Math.abs(Math.sin(walkCycle)) * 0.4;
  rightShin.rotation.x = Math.abs(Math.sin(walkCycle)) * 0.4;
}

// Movement update
function updateMovement() {
  let dirX = 0;
  let dirZ = 0;

  if (moveForward) dirZ -= 1;
  if (moveBackward) dirZ += 1;
  if (moveLeft) dirX -= 1;
  if (moveRight) dirX += 1;

  if (dirX !== 0 || dirZ !== 0) {
    const len = Math.sqrt(dirX*dirX + dirZ*dirZ);
    dirX /= len;
    dirZ /= len;

    // Rotate direction by camera azimuth + 180deg (because W moves "forward")
    const angle = azimuth + Math.PI;
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);

    const moveX = dirX*cosA - dirZ*sinA;
    const moveZ = dirX*sinA + dirZ*cosA;

    const speed = isRunning ? runSpeed : walkSpeed;

    stickman.position.x += moveX * speed;
    stickman.position.z += moveZ * speed;

    // Smooth rotation toward movement direction
    const targetRot = Math.atan2(moveX, moveZ);
    stickman.rotation.y += (targetRot - stickman.rotation.y) * 0.15;
  }

  // Jump and gravity
  if (isJumping) {
    stickman.position.y += velocityY;
    velocityY -= gravity;
    if (stickman.position.y <= 0) {
      stickman.position.y = 0;
      isJumping = false;
      velocityY = 0;
      isGrounded = true;
    } else {
      isGrounded = false;
    }
  }
}

// Animation loop
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);

  const delta = clock.getDelta();
  uniforms.time.value += delta;

  updateMovement();
  animateGait(delta);
  updateCamera();

  renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
