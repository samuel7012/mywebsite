<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Exploding Goo Blobs</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }

    canvas {
      display: block;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
<canvas id="gooCanvas"></canvas>

<script>
const canvas = document.getElementById('gooCanvas');
const ctx = canvas.getContext('2d');
let width, height;

function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

class Node {
  constructor(x, y, angle, radius, center) {
    this.center = center;
    this.angle = angle;
    this.baseRadius = radius;
    this.radius = radius;
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
  }

  update(time) {
    const wobble = Math.sin(time * 0.004 + this.angle * 3) * 4;
    const dynamicRadius = this.baseRadius + wobble;

    this.targetX = this.center.x + Math.cos(this.angle) * dynamicRadius;
    this.targetY = this.center.y + Math.sin(this.angle) * dynamicRadius;

    let dx = this.targetX - this.x;
    let dy = this.targetY - this.y;

    this.vx += dx * 0.2;
    this.vy += dy * 0.2;

    this.vx *= 0.7;
    this.vy *= 0.7;

    this.x += this.vx;
    this.y += this.vy;
  }
}

class Blob {
  constructor(x, y, color = '#00bfff') {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 2;
    this.vy = (Math.random() - 0.5) * 2;
    this.radius = 50 + Math.random() * 20;
    this.color = color;
    this.nodes = [];

    const nodeCount = 32;
    for (let i = 0; i < nodeCount; i++) {
      let angle = (Math.PI * 2 / nodeCount) * i;
      let nx = x + Math.cos(angle) * this.radius;
      let ny = y + Math.sin(angle) * this.radius;
      this.nodes.push(new Node(nx, ny, angle, this.radius, this));
    }
  }

  applyStickyOrBounce(otherBlob) {
    const dx = otherBlob.x - this.x;
    const dy = otherBlob.y - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const minDist = (this.radius + otherBlob.radius) * 0.85;

    if (dist < minDist && dist > 0) {
      const relVx = otherBlob.vx - this.vx;
      const relVy = otherBlob.vy - this.vy;
      const relativeSpeed = Math.sqrt(relVx * relVx + relVy * relVy);

      if (relativeSpeed > 2.5) {
        // ðŸ’¥ BOUNCE OFF
        const force = 0.05;
        const ax = (dx / dist) * force;
        const ay = (dy / dist) * force;

        this.vx -= ax * 5;
        this.vy -= ay * 5;
        otherBlob.vx += ax * 5;
        otherBlob.vy += ay * 5;
      } else {
        // ðŸ‘¯ Gentle stickiness
        const force = (minDist - dist) * 0.015;
        const ax = (dx / dist) * force;
        const ay = (dy / dist) * force;

        this.vx -= ax;
        this.vy -= ay;
        otherBlob.vx += ax;
        otherBlob.vy += ay;
      }
    }
  }

  update(time) {
    this.x += this.vx;
    this.y += this.vy;

    // Bounce off walls
    if (this.x - this.radius < 0 || this.x + this.radius > width) this.vx *= -1;
    if (this.y - this.radius < 0 || this.y + this.radius > height) this.vy *= -1;

    for (let node of this.nodes) {
      node.center = this;
      node.update(time);
    }
  }

  draw(ctx) {
    ctx.save();
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(this.nodes[0].x, this.nodes[0].y);
    for (let i = 1; i < this.nodes.length; i++) {
      const current = this.nodes[i];
      const prev = this.nodes[i - 1];
      const cx = (prev.x + current.x) / 2;
      const cy = (prev.y + current.y) / 2;
      ctx.quadraticCurveTo(prev.x, prev.y, cx, cy);
    }

    const first = this.nodes[0];
    const last = this.nodes[this.nodes.length - 1];
    const cx = (last.x + first.x) / 2;
    const cy = (last.y + first.y) / 2;
    ctx.quadraticCurveTo(last.x, last.y, cx, cy);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
}

const blobs = [];
const blobCount = 7;

for (let i = 0; i < blobCount; i++) {
  const x = Math.random() * width;
  const y = Math.random() * height;
  blobs.push(new Blob(x, y));
}

function animate(time) {
  ctx.clearRect(0, 0, width, height);
  ctx.imageSmoothingEnabled = false;

  // Apply sticky or bounce logic
  for (let i = 0; i < blobs.length; i++) {
    for (let j = i + 1; j < blobs.length; j++) {
      blobs[i].applyStickyOrBounce(blobs[j]);
    }
  }

  for (let blob of blobs) {
    blob.update(time);
    blob.draw(ctx);
  }

  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
