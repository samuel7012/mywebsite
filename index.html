<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stickman Obby</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #info {
      position: absolute;
      top: 10px; left: 10px;
      color: #fff; background: rgba(0,0,0,0.5);
      padding: 8px; border-radius: 5px;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
<div id="info">
  <b>W</b>: forward &nbsp; <b>S</b>: backward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
  <b>Shift</b>: run &nbsp; <b>Space</b>: jump
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x223);

// Camera
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, 10);

// Renderer
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Sun (visual)
const sunGeometry = new THREE.SphereGeometry(1.2, 32, 32);
const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffffaa, emissive: 0xffff66 });
const sun = new THREE.Mesh(sunGeometry, sunMaterial);
sun.position.copy(directionalLight.position);
scene.add(sun);

// Ground
const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x226622 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// Platforms
const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x00cc66 });
const platforms = [];

const addPlatform = (x, y, z, w=3, h=0.3, d=3) => {
  const platGeo = new THREE.BoxGeometry(w, h, d);
  const plat = new THREE.Mesh(platGeo, platformMaterial);
  plat.position.set(x, y, z);
  plat.userData = { width: w, height: h, depth: d };
  scene.add(plat);
  platforms.push(plat);
};

addPlatform(0, 0.15, 0);
addPlatform(5, 0.5, -5);
addPlatform(10, 1.2, -10);
addPlatform(15, 2.0, -15);
addPlatform(20, 2.0, -10, 6);
addPlatform(27, 1.0, -5);
addPlatform(32, 0.15, 0);

// Stickman (simple)
const stickman = new THREE.Group();
const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 2), new THREE.MeshStandardMaterial({color: 0xaaaaaa}));
const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshStandardMaterial({color: 0xeeeeee}));
head.position.y = 1.3;
stickman.add(body);
stickman.add(head);
scene.add(stickman);

// Controls
const keys = {};
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// Movement
let velocityY = 0;
let isJumping = false;
let isGrounded = false;
const gravity = 0.02;
const speed = 0.1;
const runMultiplier = 2;
const STICKMAN_HEIGHT = 2;

function animate() {
  requestAnimationFrame(animate);

  let moveSpeed = speed * (keys['shift'] ? runMultiplier : 1);
  let dirX = 0, dirZ = 0;

  if (keys['w']) dirZ -= moveSpeed;
  if (keys['s']) dirZ += moveSpeed;
  if (keys['a']) dirX -= moveSpeed;
  if (keys['d']) dirX += moveSpeed;

  stickman.position.x += dirX;
  stickman.position.z += dirZ;

  // Jump
  if (keys[' '] && isGrounded) {
    velocityY = 0.3;
    isJumping = true;
    isGrounded = false;
  }

  // Apply gravity
  stickman.position.y += velocityY;
  velocityY -= gravity;

  // Platform collision
  let landed = false;
  for (let plat of platforms) {
    const px = plat.position.x;
    const py = plat.position.y + plat.userData.height / 2;
    const pz = plat.position.z;
    const w = plat.userData.width / 2;
    const d = plat.userData.depth / 2;

    const sx = stickman.position.x;
    const sz = stickman.position.z;
    const footY = stickman.position.y - STICKMAN_HEIGHT / 2;

    const withinXZ = (sx > px - w && sx < px + w && sz > pz - d && sz < pz + d);
    const hittingFromAbove = (footY >= py && footY + velocityY <= py + 0.01);

    if (withinXZ && hittingFromAbove) {
      stickman.position.y = py + STICKMAN_HEIGHT / 2;
      velocityY = 0;
      isJumping = false;
      isGrounded = true;
      landed = true;
      break;
    }
  }

  // Fall to ground
  if (!landed && stickman.position.y <= STICKMAN_HEIGHT / 2) {
    stickman.position.y = STICKMAN_HEIGHT / 2;
    velocityY = 0;
    isJumping = false;
    isGrounded = true;
  } else if (!landed) {
    isGrounded = false;
  }

  // Camera follows behind
  camera.position.set(
    stickman.position.x - 5,
    stickman.position.y + 4,
    stickman.position.z + 6
  );
  camera.lookAt(stickman.position);

  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
