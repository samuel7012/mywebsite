<html lang="en">
<head>
<meta charset="UTF-8">
<title>TESTING IN PROGRES</title>
<style>
body { margin: 0; overflow: hidden; }
#info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; }
</style>
</head>
<body>
<div id="info" style="display:none">
<b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
<b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
<b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)<br>
<b>Arrow Keys</b>: Rotate camera
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
  
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);

let cameraMode = 1; // 1: third-person, 2: first-person, 3: top-down

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Ground
const groundGeometry = new THREE.PlaneGeometry(100, 100);
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// Stickman setup (unchanged from your code) ...
// [ ... stickman creation code here ... ] 
// I won't repeat it here, but in your file it remains unchanged.

// Movement state
let moveBackward = false, moveForward = false, moveLeft = false, moveRight = false;
let isRunning = false;
let isJumping = false;
let isGrounded = true;
let velocityY = 0;
const walkSpeed = 0.08;
const runSpeed = 0.16;
const jumpStrength = 0.24;
const gravity = 0.012;
let walkCycle = 0; // for gait animation

// Camera control variables
let azimuth = 0;
let polar = Math.PI/5;
let radius = 8;
const minPolar = 0.1;
const maxPolar = Math.PI/2 - 0.05;

// Arrow key camera rotation
const arrowRotationSpeed = 0.03;
window.addEventListener('keydown', function(e){
switch(e.key) {
case 'w': moveBackward = true; break;
case 's': moveForward = true; break;
case 'a': moveLeft = true; break;
case 'd': moveRight = true; break;
case 'Shift': isRunning = true; break;
case ' ': 
  if (isGrounded && !isJumping) {
    isJumping = true;
    velocityY = jumpStrength;
  }
  break;
case '1': cameraMode = 1; break;
case '2': cameraMode = 2; break;
case '3': cameraMode = 3; break;
// Arrow camera control
case 'ArrowLeft': azimuth -= arrowRotationSpeed; break;
case 'ArrowRight': azimuth += arrowRotationSpeed; break;
case 'ArrowUp': polar -= arrowRotationSpeed; polar = Math.max(minPolar, Math.min(maxPolar, polar)); break;
case 'ArrowDown': polar += arrowRotationSpeed; polar = Math.max(minPolar, Math.min(maxPolar, polar)); break;
}
});

window.addEventListener('keyup', function(e){
switch(e.key) {
case 'w': moveBackward = false; break;
case 's': moveForward = false; break;
case 'a': moveLeft = false; break;
case 'd': moveRight = false; break;
case 'Shift': isRunning = false; break;
}
});

// Mouse orbit controls (unchanged from your code) ...
let lastMouse = {x: window.innerWidth/2, y: window.innerHeight/2};
let mouseInitialized = false;
const mouseSensitivity = 0.005;

document.addEventListener('mousemove', function(e){
if (cameraMode === 2) return;
if (!mouseInitialized) {
lastMouse.x = e.clientX; lastMouse.y = e.clientY;
mouseInitialized = true;
return;
}
let dx = e.clientX - lastMouse.x;
let dy = e.clientY - lastMouse.y;
azimuth -= dx * mouseSensitivity;
polar -= dy * mouseSensitivity;
polar = Math.max(minPolar, Math.min(maxPolar, polar));
lastMouse.x = e.clientX;
lastMouse.y = e.clientY;
});

document.addEventListener('mouseleave', function(){
mouseInitialized = false;
});

renderer.domElement.addEventListener('wheel', function(e){
if (cameraMode === 2) return;
radius += e.deltaY * 0.01;
radius = Math.max(2, Math.min(30, radius));
});

function updateCamera() {
  if (cameraMode === 1) {
    let camX = stickman.position.x + radius * Math.sin(polar) * Math.sin(azimuth);
    let camY = stickman.position.y + radius * Math.cos(polar) + 1;
    let camZ = stickman.position.z + radius * Math.sin(polar) * Math.cos(azimuth);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(stickman.position.x, stickman.position.y + 1.4, stickman.position.z);
  } else if (cameraMode === 2) {
    camera.position.set(stickman.position.x, stickman.position.y + 2.25, stickman.position.z);
    const lookX = stickman.position.x + Math.sin(azimuth);
    const lookY = stickman.position.y + 2.25;
    const lookZ = stickman.position.z + Math.cos(azimuth);
    camera.lookAt(lookX, lookY, lookZ);
  } else if (cameraMode === 3) {
    let camX = stickman.position.x + radius * Math.sin(azimuth);
    let camY = stickman.position.y + 15;
    let camZ = stickman.position.z + radius * Math.cos(azimuth);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(stickman.position.x, stickman.position.y, stickman.position.z);
  }
}

// animateStickman function stays as in your code

// Animate
function animate() {
requestAnimationFrame(animate);

// Movement code unchanged from yours ...

updateCamera();
renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', function() {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
