<html lang="en">
<head>
<meta charset="UTF-8">
  <title>TESTING IN PROGRES</title>
<style>
body { margin: 0; overflow: hidden; }
#info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; }
</style>
</head>
<body>
<div id="info">
<b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
<b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
<b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);

let cameraMode = 1; // 1: third-person, 2: first-person, 3: top-down

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// ======= PLATFORM CREATION: Diverse directions =======
const platforms = [];
function createPlatform(x, y, z, width, height, depth, color=0x8888ff) {
  const geometry = new THREE.BoxGeometry(width, height, depth);
  const material = new THREE.MeshStandardMaterial({ color, emissive: 0x222244 });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x, y + height / 2, z); // y is bottom height
  mesh.userData = { width, height, depth };
  scene.add(mesh);
  platforms.push(mesh);
}

// Create 30 platforms scattered around in diverse directions
const numPlatforms = 30;
let lastPos = {x: 0, y: 0, z: 0};
for (let i = 0; i < numPlatforms; i++) {
  // Spiral/branching effect: each platform is offset in a random direction
  const angle = Math.random() * Math.PI * 2;
  const dist = 2.5 + Math.random() * 2;
  const heightStep = 1.7 + Math.random() * 0.5;
  let x = lastPos.x + Math.cos(angle) * dist;
  let z = lastPos.z + Math.sin(angle) * dist;
  let y = lastPos.y + heightStep * (Math.random() < 0.8 ? 1 : 0.45); // sometimes smaller step for challenge
  const color = `0x${Math.floor(Math.random()*16777215).toString(16).padStart(6,"0")}`;
  createPlatform(x, y, z, 2.3 + Math.random()*0.7, 0.4, 2.3 + Math.random()*0.7, color);
  lastPos = {x, y, z};
}
// ======= END PLATFORM CREATION =======

// Stickman group (perfect stickman proportions and joints)
const stickman = new THREE.Group();
// (Stickman code unchanged...)

const stickMat = new THREE.MeshStandardMaterial({color: 0x181818});
const headMat = new THREE.MeshStandardMaterial({color: 0xffffff});

const head = new THREE.Mesh(
new THREE.SphereGeometry(0.28, 32, 32),
headMat
);
head.position.y = 2.25;
stickman.add(head);

const body = new THREE.Mesh(
new THREE.CylinderGeometry(0.06, 0.06, 0.95, 20),
stickMat
);
body.position.y = 1.5;
stickman.add(body);

const shoulders = new THREE.Mesh(
new THREE.SphereGeometry(0.09, 20, 16),
stickMat
);
shoulders.position.y = 1.98;
stickman.add(shoulders);

const hips = new THREE.Mesh(
new THREE.SphereGeometry(0.085, 18, 12),
stickMat
);
hips.position.y = 1.02;
stickman.add(hips);

// Arms and Legs as groups for animation
const leftArm = new THREE.Group();
leftArm.position.set(-0.19, 1.9, 0);
stickman.add(leftArm);
const upperArmL = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14),
stickMat
);
upperArmL.position.y = -0.245;
leftArm.add(upperArmL);
const elbowL = new THREE.Mesh(
new THREE.SphereGeometry(0.06, 12, 10),
stickMat
);
elbowL.position.y = -0.49;
leftArm.add(elbowL);
const leftForearm = new THREE.Group();
leftForearm.position.y = -0.49;
const lowerArmL = new THREE.Mesh(
new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12),
stickMat
);
lowerArmL.position.y = -0.21;
leftForearm.add(lowerArmL);
const handL = new THREE.Mesh(
new THREE.SphereGeometry(0.045, 10, 8),
stickMat
);
handL.position.y = -0.42;
leftForearm.add(handL);
leftArm.add(leftForearm);

const rightArm = new THREE.Group();
rightArm.position.set(0.19, 1.9, 0);
stickman.add(rightArm);
const upperArmR = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14),
stickMat
);
upperArmR.position.y = -0.245;
rightArm.add(upperArmR);
const elbowR = new THREE.Mesh(
new THREE.SphereGeometry(0.06, 12, 10),
stickMat
);
elbowR.position.y = -0.49;
rightArm.add(elbowR);
const rightForearm = new THREE.Group();
rightForearm.position.y = -0.49;
const lowerArmR = new THREE.Mesh(
new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12),
stickMat
);
lowerArmR.position.y = -0.21;
rightForearm.add(lowerArmR);
const handR = new THREE.Mesh(
new THREE.SphereGeometry(0.045, 10, 8),
stickMat
);
handR.position.y = -0.42;
rightForearm.add(handR);
rightArm.add(rightForearm);

// LEFT LEG
const leftLeg = new THREE.Group();
leftLeg.position.set(-0.07, 0.99, 0);
stickman.add(leftLeg);
const upperLegL = new THREE.Mesh(
new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14),
stickMat
);
upperLegL.position.y = -0.29;
leftLeg.add(upperLegL);
const kneeL = new THREE.Mesh(
new THREE.SphereGeometry(0.07, 12, 8),
stickMat
);
kneeL.position.y = -0.58;
leftLeg.add(kneeL);
const leftShin = new THREE.Group();
leftShin.position.y = -0.58;
const lowerLegL = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12),
stickMat
);
lowerLegL.position.y = -0.245;
leftShin.add(lowerLegL);
const footL = new THREE.Mesh(
new THREE.SphereGeometry(0.05, 10, 8),
stickMat
);
footL.position.y = -0.49;
leftShin.add(footL);
leftLeg.add(leftShin);

// RIGHT LEG
const rightLeg = new THREE.Group();
rightLeg.position.set(0.07, 0.99, 0);
stickman.add(rightLeg);
const upperLegR = new THREE.Mesh(
new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14),
stickMat
);
upperLegR.position.y = -0.29;
rightLeg.add(upperLegR);
const kneeR = new THREE.Mesh(
new THREE.SphereGeometry(0.07, 12, 8),
stickMat
);
kneeR.position.y = -0.58;
rightLeg.add(kneeR);
const rightShin = new THREE.Group();
rightShin.position.y = -0.58;
const lowerLegR = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12),
stickMat
);
lowerLegR.position.y = -0.245;
rightShin.add(lowerLegR);
const footR = new THREE.Mesh(
new THREE.SphereGeometry(0.05, 10, 8),
stickMat
);
footR.position.y = -0.49;
rightShin.add(footR);
rightLeg.add(rightShin);

scene.add(stickman);

// Movement state (unchanged)
// ... (rest of your movement and animation code below)
</script>
</body>
</html>
