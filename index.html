<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stickman Fall Off Platform</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0,0,0,0.5);
      padding: 8px;
      border-radius: 5px;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
<div id="info">
  <b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
  Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
  <b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
  <b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

// Camera
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);
let cameraMode = 1;

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
dirLight.position.set(5, 10, 7.5);
scene.add(dirLight);

// Platform
const platformGeometry = new THREE.BoxGeometry(10, 1, 10);
const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
const platform = new THREE.Mesh(platformGeometry, platformMaterial);
platform.position.y = -0.5;
scene.add(platform);

// Stickman
const stickman = new THREE.Group();
const mat = new THREE.MeshStandardMaterial({ color: 0x222222 });
const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

// Head
const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 16, 16), whiteMat);
head.position.y = 2.25;
stickman.add(head);

// Body
const body = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.95, 10), mat);
body.position.y = 1.5;
stickman.add(body);

// Arms & legs (simplified for brevity)
function makeLimb(length, radius) {
  const group = new THREE.Group();
  const upper = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, length, 8), mat);
  upper.position.y = -length / 2;
  group.add(upper);
  return group;
}
const leftArm = makeLimb(0.5, 0.045); leftArm.position.set(-0.25, 1.95, 0); stickman.add(leftArm);
const rightArm = makeLimb(0.5, 0.045); rightArm.position.set(0.25, 1.95, 0); stickman.add(rightArm);
const leftLeg = makeLimb(0.6, 0.055); leftLeg.position.set(-0.1, 1.0, 0); stickman.add(leftLeg);
const rightLeg = makeLimb(0.6, 0.055); rightLeg.position.set(0.1, 1.0, 0); stickman.add(rightLeg);

scene.add(stickman);

// Movement state
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let isRunning = false, isJumping = false, isGrounded = true;
let velocityY = 0;
const walkSpeed = 0.08;
const runSpeed = 0.16;
const jumpStrength = 0.22;
const gravity = 0.012;

window.addEventListener('keydown', (e) => {
  switch (e.key) {
    case 'w': moveBackward = true; break;
    case 's': moveForward = true; break;
    case 'a': moveLeft = true; break;
    case 'd': moveRight = true; break;
    case 'Shift': isRunning = true; break;
    case ' ': if (isGrounded) { isJumping = true; velocityY = jumpStrength; isGrounded = false; } break;
    case '1': cameraMode = 1; break;
    case '2': cameraMode = 2; break;
    case '3': cameraMode = 3; break;
  }
});
window.addEventListener('keyup', (e) => {
  switch (e.key) {
    case 'w': moveBackward = false; break;
    case 's': moveForward = false; break;
    case 'a': moveLeft = false; break;
    case 'd': moveRight = false; break;
    case 'Shift': isRunning = false; break;
  }
});

// Mouse
let azimuth = 0, polar = Math.PI / 5, radius = 8;
let lastMouse = { x: window.innerWidth/2, y: window.innerHeight/2 };
let mouseInitialized = false;
const mouseSensitivity = 0.005;

document.addEventListener('mousemove', (e) => {
  if (cameraMode === 2) return;
  if (!mouseInitialized) {
    lastMouse.x = e.clientX;
    lastMouse.y = e.clientY;
    mouseInitialized = true;
    return;
  }
  azimuth -= (e.clientX - lastMouse.x) * mouseSensitivity;
  polar -= (e.clientY - lastMouse.y) * mouseSensitivity;
  polar = Math.max(0.1, Math.min(Math.PI / 2 - 0.05, polar));
  lastMouse.x = e.clientX;
  lastMouse.y = e.clientY;
});
renderer.domElement.addEventListener('wheel', (e) => {
  if (cameraMode !== 2) {
    radius += e.deltaY * 0.01;
    radius = Math.max(2, Math.min(30, radius));
  }
});

function updateCamera() {
  if (cameraMode === 1) {
    let camX = stickman.position.x + radius * Math.sin(polar) * Math.sin(azimuth);
    let camY = stickman.position.y + radius * Math.cos(polar) + 1;
    let camZ = stickman.position.z + radius * Math.sin(polar) * Math.cos(azimuth);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(stickman.position.x, 1.4, stickman.position.z);
  } else if (cameraMode === 2) {
    camera.position.set(stickman.position.x, stickman.position.y + 2.2, stickman.position.z + 0.2);
    camera.lookAt(stickman.position.x, stickman.position.y + 2.2, stickman.position.z + 2);
  } else if (cameraMode === 3) {
    let camX = stickman.position.x;
    let camY = stickman.position.y + 15;
    let camZ = stickman.position.z;
    camera.position.set(camX, camY, camZ);
    camera.lookAt(stickman.position.x, stickman.position.y, stickman.position.z);
  }
}

function isOnPlatform(pos) {
  const x = pos.x;
  const z = pos.z;
  const half = 5;
  return x >= -half && x <= half && z >= -half && z <= half;
}

// Animate
function animate() {
  requestAnimationFrame(animate);

  let dx = 0, dz = 0;
  const speed = isRunning ? runSpeed : walkSpeed;
  if (moveForward) { dz += speed; }
  if (moveBackward) { dz -= speed; }
  if (moveLeft) { dx -= speed; }
  if (moveRight) { dx += speed; }

  let angle = azimuth;
  let sin = Math.sin(angle), cos = Math.cos(angle);

  stickman.position.x += dx * cos - dz * sin;
  stickman.position.z += dx * sin + dz * cos;

  // Gravity & Jump
  if (!isOnPlatform(stickman.position) || !isGrounded) {
    velocityY -= gravity;
    stickman.position.y += velocityY;
    isGrounded = false;

    if (stickman.position.y <= -10) {  // Reset if fallen
      stickman.position.set(0, 0, 0);
      velocityY = 0;
      isGrounded = true;
    }
  } else {
    if (isJumping) {
      stickman.position.y += velocityY;
      velocityY -= gravity;
      if (velocityY <= 0) isJumping = false;
    } else {
      stickman.position.y = 0;
      velocityY = 0;
      isGrounded = true;
    }
  }

  updateCamera();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
