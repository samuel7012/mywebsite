<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Transformer Game - Transform Into Car</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; }
  </style>
</head>
<body>
  <div id="info">
    <b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
    Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
    <b>T</b>: Transform between robot and car<br>
    <b>Arrow keys</b> still use standard mapping<br>
    <b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
    <b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script>
    // --- Scene & Camera ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1b1e2e);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 6, 12);

    let cameraMode = 1;

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0xaaaaee, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(15, 30, 15);
    scene.add(dirLight);

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100),
      new THREE.MeshStandardMaterial({ color: 0x333347, metalness: 0.3, roughness: 0.8 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.position.y = 0;
    scene.add(ground);

    // --- Transformer Robot Model ---
    const transformer = new THREE.Group();

    // Robot Materials
    const metalBlue = new THREE.MeshStandardMaterial({color:0x1e4dac, metalness:0.7, roughness:0.3});
    const metalRed = new THREE.MeshStandardMaterial({color:0xaa2222, metalness:0.7, roughness:0.3});
    const metalSilver = new THREE.MeshStandardMaterial({color:0xdddddd, metalness:0.9, roughness:0.25});
    const metalBlack = new THREE.MeshStandardMaterial({color:0x222225, metalness:0.8, roughness:0.3});
    const glassYellow = new THREE.MeshStandardMaterial({color:0xffff44, metalness:0.6, roughness:0.1, emissive:0x222200});

    // Head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.7,0.7), metalSilver);
    head.position.y = 3.55;
    transformer.add(head);

    // Face (visor)
    const visor = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.2,0.05), glassYellow);
    visor.position.set(0, 3.55, 0.37);
    transformer.add(visor);

    // Crest
    const crest = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.25,0.22), metalRed);
    crest.position.set(0, 3.85, 0.12);
    transformer.add(crest);

    // Torso (big block)
    const torso = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.6,0.7), metalBlue);
    torso.position.y = 2.55;
    transformer.add(torso);

    // Chest plates
    const chestL = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.1), metalRed);
    chestL.position.set(-0.35,3.05,0.43);
    transformer.add(chestL);
    const chestR = chestL.clone();
    chestR.position.x = 0.35;
    transformer.add(chestR);

    // --- Arms as groups (for animation) ---
    // Left Arm
    const leftArm = new THREE.Group();
    leftArm.position.set(-0.85, 3.2, 0);

    // Left upper arm
    const upperArmL = new THREE.Mesh(new THREE.BoxGeometry(0.38,0.8,0.38), metalRed);
    upperArmL.position.y = -0.4;
    leftArm.add(upperArmL);

    // Left elbow joint
    const elbowL = new THREE.Mesh(new THREE.CylinderGeometry(0.14,0.14,0.16,16), metalBlack);
    elbowL.rotation.z = Math.PI/2;
    elbowL.position.y = -0.8;
    leftArm.add(elbowL);

    // Left forearm (lower arm)
    const leftForearm = new THREE.Group();
    leftForearm.position.y = -0.88;
    const foreArmL = new THREE.Mesh(new THREE.BoxGeometry(0.32,0.7,0.32), metalBlue);
    foreArmL.position.y = -0.35;
    leftForearm.add(foreArmL);

    // Left hand
    const handL = new THREE.Mesh(new THREE.BoxGeometry(0.23,0.23,0.23), metalSilver);
    handL.position.y = -0.7;
    leftForearm.add(handL);

    leftArm.add(leftForearm);
    transformer.add(leftArm);

    // Right Arm
    const rightArm = new THREE.Group();
    rightArm.position.set(0.85, 3.2, 0);

    // Right upper arm
    const upperArmR = new THREE.Mesh(new THREE.BoxGeometry(0.38,0.8,0.38), metalRed);
    upperArmR.position.y = -0.4;
    rightArm.add(upperArmR);

    // Right elbow joint
    const elbowR = new THREE.Mesh(new THREE.CylinderGeometry(0.14,0.14,0.16,16), metalBlack);
    elbowR.rotation.z = Math.PI/2;
    elbowR.position.y = -0.8;
    rightArm.add(elbowR);

    // Right forearm (lower arm)
    const rightForearm = new THREE.Group();
    rightForearm.position.y = -0.88;
    const foreArmR = new THREE.Mesh(new THREE.BoxGeometry(0.32,0.7,0.32), metalBlue);
    foreArmR.position.y = -0.35;
    rightForearm.add(foreArmR);

    // Right hand
    const handR = new THREE.Mesh(new THREE.BoxGeometry(0.23,0.23,0.23), metalSilver);
    handR.position.y = -0.7;
    rightForearm.add(handR);

    rightArm.add(rightForearm);
    transformer.add(rightArm);

    // --- Legs as groups (for animation) ---
    // Left Leg
    const leftLeg = new THREE.Group();
    leftLeg.position.set(-0.37, 1.33, 0);

    // Left upper leg
    const upperLegL = new THREE.Mesh(new THREE.BoxGeometry(0.35,0.85,0.35), metalBlue);
    upperLegL.position.y = -0.425;
    leftLeg.add(upperLegL);

    // Left knee joint
    const kneeL = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,0.18,16), metalBlack);
    kneeL.rotation.z = Math.PI/2;
    kneeL.position.y = -0.85;
    leftLeg.add(kneeL);

    // Left lower leg (shin)
    const leftShin = new THREE.Group();
    leftShin.position.y = -0.93;
    const lowerLegL = new THREE.Mesh(new THREE.BoxGeometry(0.26,0.7,0.26), metalSilver);
    lowerLegL.position.y = -0.35;
    leftShin.add(lowerLegL);

    // Left foot
    const footL = new THREE.Mesh(new THREE.BoxGeometry(0.28,0.12,0.5), metalBlack);
    footL.position.y = -0.75;
    footL.position.z = 0.13;
    leftShin.add(footL);

    leftLeg.add(leftShin);
    transformer.add(leftLeg);

    // Right Leg
    const rightLeg = new THREE.Group();
    rightLeg.position.set(0.37, 1.33, 0);

    // Right upper leg
    const upperLegR = new THREE.Mesh(new THREE.BoxGeometry(0.35,0.85,0.35), metalBlue);
    upperLegR.position.y = -0.425;
    rightLeg.add(upperLegR);

    // Right knee joint
    const kneeR = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,0.18,16), metalBlack);
    kneeR.rotation.z = Math.PI/2;
    kneeR.position.y = -0.85;
    rightLeg.add(kneeR);

    // Right lower leg (shin)
    const rightShin = new THREE.Group();
    rightShin.position.y = -0.93;
    const lowerLegR = new THREE.Mesh(new THREE.BoxGeometry(0.26,0.7,0.26), metalSilver);
    lowerLegR.position.y = -0.35;
    rightShin.add(lowerLegR);

    // Right foot
    const footR = new THREE.Mesh(new THREE.BoxGeometry(0.28,0.12,0.5), metalBlack);
    footR.position.y = -0.75;
    footR.position.z = 0.13;
    rightShin.add(footR);

    rightLeg.add(rightShin);
    transformer.add(rightLeg);

    // --- Car Model ---
    const car = new THREE.Group();

    // Car Body
    const carBody = new THREE.Mesh(new THREE.BoxGeometry(2.2,0.5,4.2), metalBlue);
    carBody.position.y = 0.5;
    car.add(carBody);

    // Car Roof
    const carRoof = new THREE.Mesh(new THREE.BoxGeometry(1.3,0.35,1.8), metalSilver);
    carRoof.position.set(0,0.85,0.3);
    car.add(carRoof);

    // Car Front (grill)
    const carGrill = new THREE.Mesh(new THREE.BoxGeometry(1,0.22,0.44), metalBlack);
    carGrill.position.set(0,0.52,2.1);
    car.add(carGrill);

    // Car Windshield
    const carWindow = new THREE.Mesh(new THREE.BoxGeometry(1.22,0.25,0.02), glassYellow);
    carWindow.position.set(0,1,1.0);
    car.add(carWindow);

    // Car Wheels
    function makeWheel(x, z) {
      const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.38,0.38,0.22,20), metalBlack);
      wheel.rotation.z = Math.PI/2;
      wheel.position.set(x,0.2,z);
      return wheel;
    }
    car.add(makeWheel(-1, -1.7));
    car.add(makeWheel(1, -1.7));
    car.add(makeWheel(-1, 1.7));
    car.add(makeWheel(1, 1.7));

    car.visible = false;
    scene.add(car);

    // --- Transform State ---
    let isCar = false;
    let transformAnim = 0; // 0=robot, 1=car, animates between

    // --- Controls & Animation State ---
    let moveBackward = false, moveForward = false, moveLeft = false, moveRight = false;
    let isRunning = false;
    let isJumping = false;
    let isGrounded = true;
    let velocityY = 0;
    const walkSpeed = 0.09;
    const runSpeed = 0.18;
    const carSpeed = 0.26;
    const jumpStrength = 0.30;
    const gravity = 0.012;
    let walkCycle = 0;

    window.addEventListener('keydown', function(e){
      switch(e.key) {
        case 'w': moveBackward = true; break;
        case 's': moveForward = true; break;
        case 'a': moveLeft = true; break;
        case 'd': moveRight = true; break;
        case 'ArrowUp': moveForward = true; break;
        case 'ArrowDown': moveBackward = true; break;
        case 'ArrowLeft': moveLeft = true; break;
        case 'ArrowRight': moveRight = true; break;
        case 'Shift': isRunning = true; break;
        case ' ':
          if (!isCar && isGrounded && !isJumping) {
            isJumping = true;
            velocityY = jumpStrength;
          }
          break;
        case 't':
        case 'T':
          isCar = !isCar;
          break;
        case '1': cameraMode = 1; break;
        case '2': cameraMode = 2; break;
        case '3': cameraMode = 3; break;
      }
    });

    window.addEventListener('keyup', function(e){
      switch(e.key) {
        case 'w': moveBackward = false; break;
        case 's': moveForward = false; break;
        case 'a': moveLeft = false; break;
        case 'd': moveRight = false; break;
        case 'ArrowUp': moveForward = false; break;
        case 'ArrowDown': moveBackward = false; break;
        case 'ArrowLeft': moveLeft = false; break;
        case 'ArrowRight': moveRight = false; break;
        case 'Shift': isRunning = false; break;
      }
    });

    // Mouse camera
    let azimuth = 0;
    let polar = Math.PI/5;
    let radius = 10;
    const minPolar = 0.1;
    const maxPolar = Math.PI/2 - 0.05;
    let lastMouse = {x: window.innerWidth/2, y: window.innerHeight/2};
    let mouseInitialized = false;
    const mouseSensitivity = 0.005;

    document.addEventListener('mousemove', function(e){
      if (cameraMode === 2) return;
      if (!mouseInitialized) {
        lastMouse.x = e.clientX; lastMouse.y = e.clientY;
        mouseInitialized = true;
        return;
      }
      let dx = e.clientX - lastMouse.x;
      let dy = e.clientY - lastMouse.y;
      azimuth -= dx * mouseSensitivity;
      polar -= dy * mouseSensitivity;
      polar = Math.max(minPolar, Math.min(maxPolar, polar));
      lastMouse.x = e.clientX;
      lastMouse.y = e.clientY;
    });

    document.addEventListener('mouseleave', function(){
      mouseInitialized = false;
    });

    renderer.domElement.addEventListener('wheel', function(e){
      if (cameraMode === 2) return;
      radius += e.deltaY * 0.01;
      radius = Math.max(2, Math.min(30, radius));
    });

    function updateCamera(target) {
      if (cameraMode === 1) {
        let camX = target.position.x + radius * Math.sin(polar) * Math.sin(azimuth);
        let camY = target.position.y + radius * Math.cos(polar) + 2.5;
        let camZ = target.position.z + radius * Math.sin(polar) * Math.cos(azimuth);
        camera.position.set(camX, camY, camZ);
        camera.lookAt(target.position.x, 2.5, target.position.z);
      } else if (cameraMode === 2) {
        camera.position.x = target.position.x;
        camera.position.y = target.position.y + (isCar ? 1.2 : 3.5);
        camera.position.z = target.position.z + 0.5;
        camera.lookAt(
          target.position.x,
          target.position.y + (isCar ? 1.2 : 3.5),
          target.position.z + 2
        );
      } else if (cameraMode === 3) {
        let camX = target.position.x + radius * Math.sin(azimuth);
        let camY = target.position.y + 20;
        let camZ = target.position.z + radius * Math.cos(azimuth);
        camera.position.set(camX, camY, camZ);
        camera.lookAt(target.position.x, target.position.y, target.position.z);
      }
    }

    // --- Animation Logic ---
    function animateTransformer(state, lerp) {
      // lerp: 0=robot, 1=car
      // Animate robot parts to car pose
      // Head, arms, torso go down and shrink; legs together, flatten out

      // HEAD
      head.position.y = 3.55 - lerp * 3.05;
      visor.position.y = 3.55 - lerp * 3.05;
      crest.position.y = 3.85 - lerp * 3.25;
      // Shrink head
      head.scale.setScalar(1 - lerp * 0.7);
      visor.scale.set(1, 1 - lerp, 1 - lerp*0.7);
      crest.scale.set(1, 1 - lerp, 1 - lerp*0.7);

      // TORSO
      torso.position.y = 2.55 - lerp * 1.05;
      torso.scale.y = 1 - lerp * 0.65;
      torso.scale.z = 1 + lerp * 5;

      // Chest plates
      chestL.position.y = 3.05 - lerp * 2.15;
      chestL.position.z = 0.43 + lerp * 2.2;
      chestL.rotation.x = -lerp*1.2;
      chestL.scale.y = 1 - lerp*0.7;
      chestR.position.y = 3.05 - lerp * 2.15;
      chestR.position.z = 0.43 + lerp * 2.2;
      chestR.rotation.x = -lerp*1.2;
      chestR.scale.y = 1 - lerp*0.7;

      // ARMS: flatten to side, rotate down, shrink
      leftArm.position.set(-0.85 + lerp*0.75, 3.2 - lerp*2.3, lerp*1.3);
      leftArm.rotation.x = -lerp * Math.PI/2;
      leftArm.scale.set(1 - lerp*0.35, 1 - lerp*0.6, 1 - lerp*0.2);

      rightArm.position.set(0.85 - lerp*0.75, 3.2 - lerp*2.3, lerp*1.3);
      rightArm.rotation.x = -lerp * Math.PI/2;
      rightArm.scale.set(1 - lerp*0.35, 1 - lerp*0.6, 1 - lerp*0.2);

      // Forearms/Hands: flatten in
      leftForearm.rotation.x = lerp * Math.PI/2;
      rightForearm.rotation.x = lerp * Math.PI/2;

      // LEGS: together, rotate, flatten, scale up
      leftLeg.position.set(-0.37 + lerp*0.37, 1.33 - lerp*1.05, lerp*1.0);
      leftLeg.rotation.x = lerp * Math.PI/2;
      leftLeg.scale.set(1 - lerp*0.3, 1 - lerp*0.5, 1 + lerp*1.8);

      rightLeg.position.set(0.37 - lerp*0.37, 1.33 - lerp*1.05, lerp*1.0);
      rightLeg.rotation.x = lerp * Math.PI/2;
      rightLeg.scale.set(1 - lerp*0.3, 1 - lerp*0.5, 1 + lerp*1.8);

      // SHINS: flatten
      leftShin.rotation.x = lerp * Math.PI/2;
      rightShin.rotation.x = lerp * Math.PI/2;
    }

    function animateRobotMotion(state) {
      // Arms and legs swing as robot only (not in car)
      let t = walkCycle;
      if (state === "idle") {
        leftArm.rotation.x = 0;
        rightArm.rotation.x = 0;
        leftForearm.rotation.x = 0;
        rightForearm.rotation.x = 0;
        leftLeg.rotation.x = 0;
        rightLeg.rotation.x = 0;
        leftShin.rotation.x = 0;
        rightShin.rotation.x = 0;
      } else if (state === "walk" || state === "run") {
        let freq = state === "walk" ? 5 : 10;
        let ampArm = state === "walk" ? 0.4 : 0.8;
        let ampLeg = state === "walk" ? 0.5 : 0.9;
        let shinamp = state === "walk" ? 0.3 : 0.6;
        let phase = t * freq;

        leftArm.rotation.x = Math.sin(phase) * ampArm;
        rightArm.rotation.x = Math.sin(phase + Math.PI) * ampArm;
        leftForearm.rotation.x = 0;
        rightForearm.rotation.x = 0;
        leftLeg.rotation.x = Math.sin(phase) * ampLeg;
        rightLeg.rotation.x = Math.sin(phase + Math.PI) * ampLeg;
        leftShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4)) * shinamp;
        rightShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4 + Math.PI)) * shinamp;
      } else if (state === "jump") {
        leftArm.rotation.x = -1.0;
        rightArm.rotation.x = -1.0;
        leftForearm.rotation.x = -0.3;
        rightForearm.rotation.x = -0.3;
        leftLeg.rotation.x = 0.7;
        rightLeg.rotation.x = 0.7;
        leftShin.rotation.x = 0.55;
        rightShin.rotation.x = 0.55;
      }
    }

    // --- Main Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);

      // --- Transform Animation ---
      if (isCar && transformAnim < 1) {
        transformAnim += 0.08;
        if (transformAnim > 1) transformAnim = 1;
      }
      if (!isCar && transformAnim > 0) {
        transformAnim -= 0.08;
        if (transformAnim < 0) transformAnim = 0;
      }

      // Show/hide models
      transformer.visible = (transformAnim < 1);
      car.visible = (transformAnim > 0);

      // Car follows robot position/rotation
      car.position.copy(transformer.position);
      car.rotation.y = transformer.rotation.y;

      // --- Movement ---
      let dx = 0, dz = 0;
      let speed = (transformAnim > 0.7) ? carSpeed : (isRunning ? runSpeed : walkSpeed);

      // WASD mapping
      if (moveForward) {
        dx += Math.sin(azimuth) * speed;
        dz += Math.cos(azimuth) * speed;
      }
      if (moveBackward) {
        dx -= Math.sin(azimuth) * speed;
        dz -= Math.cos(azimuth) * speed;
      }
      if (moveLeft) {
        dx += Math.sin(azimuth - Math.PI/2) * speed;
        dz += Math.cos(azimuth - Math.PI/2) * speed;
      }
      if (moveRight) {
        dx += Math.sin(azimuth + Math.PI/2) * speed;
        dz += Math.cos(azimuth + Math.PI/2) * speed;
      }

      // Apply movement
      if (transformAnim < 1) {
        transformer.position.x += dx;
        transformer.position.z += dz;
      } else {
        car.position.x += dx;
        car.position.z += dz;
      }

      // --- Gravity & Jump ---
      if(transformAnim < 0.7) { // only robot can jump
        if(isJumping || !isGrounded) {
          transformer.position.y += velocityY;
          velocityY -= gravity;
          if(transformer.position.y <= 0) {
            transformer.position.y = 0;
            isJumping = false;
            isGrounded = true;
            velocityY = 0;
          } else {
            isGrounded = false;
          }
        } else {
          transformer.position.y = 0;
        }
      } else {
        transformer.position.y = 0;
      }

      // --- Rotation (face movement direction) ---
      if (cameraMode !== 3 && (dx !== 0 || dz !== 0)) {
        let th = Math.atan2(dx, dz);
        transformer.rotation.y = th;
        car.rotation.y = th;
      }

      // --- Animate Model ---
      animateTransformer("robot", transformAnim);

      if (transformAnim < 0.7) {
        // Animate robot walk/run/jump
        let state = "idle";
        if(isJumping || !isGrounded) state = "jump";
        else if(dx !== 0 || dz !== 0) state = isRunning ? "run" : "walk";
        animateRobotMotion(state);
        if(state === "walk" || state === "run") walkCycle += isRunning ? 0.18 : 0.09;
        else walkCycle += 0.012;
      }

      // --- Camera ---
      updateCamera(transformAnim < 1 ? transformer : car);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
