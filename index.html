<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Platform Collision Test</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: absolute; top: 10px; left: 10px; color: #fff;
      background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
  <div id="info">
    <b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
    Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222233);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 4, 8);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

    // Ground
    const groundGeometry = new THREE.PlaneGeometry(40, 40);
    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // Platforms
    const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
    const platforms = [];
    for (let i = -5; i <= 5; i++) {
      for (let j = -5; j <= 5; j++) {
        const tile = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 2), platformMaterial);
        tile.position.set(i * 2, 5, j * 2);
        scene.add(tile);
        platforms.push(tile);
      }
    }

    // Stickman (simple sphere placeholder)
    const stickman = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.5, 1.0, 4, 8),
      new THREE.MeshStandardMaterial({ color: 0x00ffcc })
    );
    stickman.position.set(0, 6, 0);
    scene.add(stickman);

    // Movement flags
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let isRunning = false;
    let isJumping = false;
    let isGrounded = false;

    // Velocity & constants
    let velocityY = 0;
    const gravity = 0.01;
    const walkSpeed = 0.1;
    const runSpeed = 0.2;
    let azimuth = 0;

    // Raycaster
    const raycaster = new THREE.Raycaster();

    // Controls
    document.addEventListener("keydown", e => {
      if (e.code === "KeyW") moveForward = true;
      if (e.code === "KeyS") moveBackward = true;
      if (e.code === "KeyA") moveLeft = true;
      if (e.code === "KeyD") moveRight = true;
      if (e.code === "ShiftLeft") isRunning = true;
      if (e.code === "Space" && isGrounded) {
        velocityY = 0.2;
        isJumping = true;
        isGrounded = false;
      }
    });

    document.addEventListener("keyup", e => {
      if (e.code === "KeyW") moveForward = false;
      if (e.code === "KeyS") moveBackward = false;
      if (e.code === "KeyA") moveLeft = false;
      if (e.code === "KeyD") moveRight = false;
      if (e.code === "ShiftLeft") isRunning = false;
    });

    function animate() {
      requestAnimationFrame(animate);

      // Movement
      let dx = 0, dz = 0;
      if (moveForward) {
        dx += Math.sin(azimuth) * walkSpeed;
        dz += Math.cos(azimuth) * walkSpeed;
      }
      if (moveBackward) {
        dx -= Math.sin(azimuth) * walkSpeed;
        dz -= Math.cos(azimuth) * walkSpeed;
      }
      if (moveLeft) {
        dx += Math.sin(azimuth - Math.PI/2) * walkSpeed;
        dz += Math.cos(azimuth - Math.PI/2) * walkSpeed;
      }
      if (moveRight) {
        dx += Math.sin(azimuth + Math.PI/2) * walkSpeed;
        dz += Math.cos(azimuth + Math.PI/2) * walkSpeed;
      }

      if ((moveForward || moveBackward || moveLeft || moveRight) && isRunning) {
        dx *= runSpeed / walkSpeed;
        dz *= runSpeed / walkSpeed;
      }

      stickman.position.x += dx;
      stickman.position.z += dz;

      if (isJumping || !isGrounded) {
        stickman.position.y += velocityY;
        velocityY -= gravity;

        // Raycast collision check
        raycaster.set(stickman.position.clone(), new THREE.Vector3(0, -1, 0));
        const hits = raycaster.intersectObjects(platforms);

        if (hits.length > 0) {
          const hit = hits[0];
          const platformY = hit.point.y;
          const stickmanBottom = stickman.position.y - 1;

          if (velocityY < 0 && stickmanBottom > platformY - 0.05) {
            stickman.position.y = platformY + 1;
            velocityY = 0;
            isGrounded = true;
            isJumping = false;
          } else {
            isGrounded = false;
          }
        } else {
          isGrounded = false;
        }
      }

      camera.lookAt(stickman.position);
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
