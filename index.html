<html lang="en">
<head>
<meta charset="UTF-8">
<title>BLAHHHHHHHH</title>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);

let cameraMode = 1; // 1: third-person, 2: first-person, 3: top-down

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(10, 10, 10);
scene.add(directionalLight);

// Ground
const groundGeometry = new THREE.PlaneGeometry(100, 100);
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// ---------------- PLATFORM SETUP ----------------
const platforms = [];

function createPlatform(x, y, z, w, h, d) {
  const geometry = new THREE.BoxGeometry(w, h, d);
  const material = new THREE.MeshStandardMaterial({ color: 0x696969 });
  const platform = new THREE.Mesh(geometry, material);
  platform.position.set(x, y, z);
  platform.receiveShadow = true;
  scene.add(platform);

  platform.userData.boundingBox = new THREE.Box3().setFromObject(platform);
  platforms.push(platform);
}

// Ground platform
createPlatform(0, -0.5, 0, 20, 1, 20);

// Stairs
for (let i = 0; i < 10; i++) {
  const stepX = 8;          
  const stepY = i * 1;      
  const stepZ = -9 + i * 3; 
  createPlatform(stepX, stepY, stepZ, 4, 1, 3);
}

// -------------------------------------------------

// Stickman group
const stickman = new THREE.Group();

// Materials
const stickMat = new THREE.MeshStandardMaterial({color: 0x181818});
const headMat = new THREE.MeshStandardMaterial({color: 0xffffff});

// Head
const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 32, 32), headMat);
head.position.y = 2.25;
stickman.add(head);

// Body
const body = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.95, 20), stickMat);
body.position.y = 1.5;
stickman.add(body);

// Shoulders
const shoulders = new THREE.Mesh(new THREE.SphereGeometry(0.09, 20, 16), stickMat);
shoulders.position.y = 1.98;
stickman.add(shoulders);

// Hips
const hips = new THREE.Mesh(new THREE.SphereGeometry(0.085, 18, 12), stickMat);
hips.position.y = 1.02;
stickman.add(hips);

// Arms and Legs groups
// Left Arm
const leftArm = new THREE.Group();
leftArm.position.set(-0.19, 1.9, 0);
stickman.add(leftArm);

const upperArmL = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14), stickMat);
upperArmL.position.y = -0.245;
leftArm.add(upperArmL);

const elbowL = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 10), stickMat);
elbowL.position.y = -0.49;
leftArm.add(elbowL);

const leftForearm = new THREE.Group();
leftForearm.position.y = -0.49;
const lowerArmL = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12), stickMat);
lowerArmL.position.y = -0.21;
leftForearm.add(lowerArmL);

const handL = new THREE.Mesh(new THREE.SphereGeometry(0.045, 10, 8), stickMat);
handL.position.y = -0.42;
leftForearm.add(handL);

leftArm.add(leftForearm);

// Right Arm
const rightArm = new THREE.Group();
rightArm.position.set(0.19, 1.9, 0);
stickman.add(rightArm);

const upperArmR = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14), stickMat);
upperArmR.position.y = -0.245;
rightArm.add(upperArmR);

const elbowR = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 10), stickMat);
elbowR.position.y = -0.49;
rightArm.add(elbowR);

const rightForearm = new THREE.Group();
rightForearm.position.y = -0.49;
const lowerArmR = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12), stickMat);
lowerArmR.position.y = -0.21;
rightForearm.add(lowerArmR);

const handR = new THREE.Mesh(new THREE.SphereGeometry(0.045, 10, 8), stickMat);
handR.position.y = -0.42;
rightForearm.add(handR);

rightArm.add(rightForearm);

// Left Leg
const leftLeg = new THREE.Group();
leftLeg.position.set(-0.07, 0.99, 0);
stickman.add(leftLeg);

const upperLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14), stickMat);
upperLegL.position.y = -0.29;
leftLeg.add(upperLegL);

const kneeL = new THREE.Mesh(new THREE.SphereGeometry(0.07, 12, 8), stickMat);
kneeL.position.y = -0.58;
leftLeg.add(kneeL);

const leftShin = new THREE.Group();
leftShin.position.y = -0.58;
const lowerLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12), stickMat);
lowerLegL.position.y = -0.245;
leftShin.add(lowerLegL);

const footL = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 8), stickMat);
footL.position.y = -0.49;
leftShin.add(footL);

leftLeg.add(leftShin);

// Right Leg
const rightLeg = new THREE.Group();
rightLeg.position.set(0.07, 0.99, 0);
stickman.add(rightLeg);

const upperLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14), stickMat);
upperLegR.position.y = -0.29;
rightLeg.add(upperLegR);

const kneeR = new THREE.Mesh(new THREE.SphereGeometry(0.07, 12, 8), stickMat);
kneeR.position.y = -0.58;
rightLeg.add(kneeR);

const rightShin = new THREE.Group();
rightShin.position.y = -0.58;
const lowerLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12), stickMat);
lowerLegR.position.y = -0.245;
rightShin.add(lowerLegR);

const footR = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 8), stickMat);
footR.position.y = -0.49;
rightShin.add(footR);

rightLeg.add(rightShin);

scene.add(stickman);

// Movement state
let moveBackward = false, moveForward = false, moveLeft = false, moveRight = false;
let isRunning = false;
let isJumping = false;
let isGrounded = true;
let velocityY = 0;
const walkSpeed = 0.08;
const runSpeed = 0.16;
const jumpStrength = 0.24;
const gravity = 0.012;
let walkCycle = 0;

window.addEventListener('keydown', e => {
  switch(e.key) {
    case 'w': moveBackward = true; break;
    case 's': moveForward = true; break;
    case 'a': moveLeft = true; break;
    case 'd': moveRight = true; break;
    case 'Shift': isRunning = true; break;
    case ' ':
      if (isGrounded && !isJumping) {
        isJumping = true;
        velocityY = jumpStrength;
      }
      break;
    case '1': cameraMode = 1; break;
    case '2': cameraMode = 2; break;
    case '3': cameraMode = 3; break;
  }
});

window.addEventListener('keyup', e => {
  switch(e.key) {
    case 'w': moveBackward = false; break;
    case 's': moveForward = false; break;
    case 'a': moveLeft = false; break;
    case 'd': moveRight = false; break;
    case 'Shift': isRunning = false; break;
  }
});

// Mouse orbit controls
let azimuth = 0;
let polar = Math.PI/5;
let radius = 8;
const minPolar = 0.1;
const maxPolar = Math.PI/2 - 0.05;

let lastMouse = {x: window.innerWidth/2, y: window.innerHeight/2};
let mouseInitialized = false;
const mouseSensitivity = 0.005;

document.addEventListener('mousemove', e => {
  if (cameraMode === 2) return;
  if (!mouseInitialized) {
    lastMouse.x = e.clientX;
    lastMouse.y = e.clientY;
    mouseInitialized = true;
    return;
  }
  let dx = e.clientX - lastMouse.x;
  let dy = e.clientY - lastMouse.y;
  azimuth -= dx * mouseSensitivity;
  polar -= dy * mouseSensitivity;
  polar = Math.max(minPolar, Math.min(maxPolar, polar));
  lastMouse.x = e.clientX;
  lastMouse.y = e.clientY;
});

document.addEventListener('mouseleave', () => mouseInitialized = false);

renderer.domElement.addEventListener('wheel', e => {
  if (cameraMode === 2) return;
  radius += e.deltaY * 0.01;
  radius = Math.max(2, Math.min(30, radius));
});

// ---------------- COLLISION DETECTION ----------------
function updateCollisions() {
  const stickmanBox = new THREE.Box3().setFromCenterAndSize(
    new THREE.Vector3(
      stickman.position.x,
      stickman.position.y + 1, // center at body
      stickman.position.z
    ),
    new THREE.Vector3(0.6, 2, 0.6)
  );

  let onPlatform = false;
  for (let p of platforms) {
    p.userData.boundingBox.setFromObject(p);
    if (stickmanBox.intersectsBox(p.userData.boundingBox)) {
      const topY = p.position.y + (p.geometry.parameters.height / 2);
      if (stickman.position.y <= topY) {
        stickman.position.y = topY;
        velocityY = 0;
        isGrounded = true;
        isJumping = false;
        onPlatform = true;
      }
    }
  }

  if (!onPlatform && stickman.position.y > -5) {
    isGrounded = false;
  }
}
// -----------------------------------------------------

function updateCamera() {
  if (cameraMode === 1) {
    let camX = stickman.position.x + radius * Math.sin(polar) * Math.sin(azimuth);
    let camY = stickman.position.y + radius * Math.cos(polar) + 1;
    let camZ = stickman.position.z + radius * Math.sin(polar) * Math.cos(azimuth);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(stickman.position.x, stickman.position.y + 1.4, stickman.position.z);
  } else if (cameraMode === 2) {
    camera.position.set(stickman.position.x, stickman.position.y + 2.25, stickman.position.z);
    const lookX = stickman.position.x + Math.sin(azimuth);
    const lookY = stickman.position.y + 2.25;
    const lookZ = stickman.position.z + Math.cos(azimuth);
    camera.lookAt(lookX, lookY, lookZ);
  } else if (cameraMode === 3) {
    let camX = stickman.position.x + radius * Math.sin(azimuth);
    let camY = stickman.position.y + 15;
    let camZ = stickman.position.z + radius * Math.cos(azimuth);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(stickman.position.x, stickman.position.y, stickman.position.z);
  }
}

function animateStickman(state) {
  let t = walkCycle;
  if (state === "idle") {
    leftArm.rotation.x = 0;
    rightArm.rotation.x = 0;
    leftForearm.rotation.x = 0;
    rightForearm.rotation.x = 0;
    leftLeg.rotation.x = 0;
    rightLeg.rotation.x = 0;
    leftShin.rotation.x = 0;
    rightShin.rotation.x = 0;
  } else if (state === "walk") {
    let freq = 5;
    let ampArm = 0.65;
    let ampLeg = 0.7;
    let shinamp = 0.47;
    let phase = t * freq;
    leftArm.rotation.x = Math.sin(phase) * ampArm;
    rightArm.rotation.x = Math.sin(phase + Math.PI) * ampArm;
    leftLeg.rotation.x = Math.sin(phase) * ampLeg;
    rightLeg.rotation.x = Math.sin(phase + Math.PI) * ampLeg;
    leftShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4)) * shinamp;
    rightShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4 + Math.PI)) * shinamp;
  } else if (state === "run") {
    let freq = 9.5;
    let ampArm = 1.6;
    let ampLeg = 1.8;
    let shinamp = 1.35;
    let phase = t * freq;
    leftArm.rotation.x = Math.sin(phase) * ampArm;
    rightArm.rotation.x = Math.sin(phase + Math.PI) * ampArm;
    leftLeg.rotation.x = Math.sin(phase) * ampLeg;
    rightLeg.rotation.x = Math.sin(phase + Math.PI) * ampLeg;
    leftShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4)) * shinamp;
    rightShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4 + Math.PI)) * shinamp;
  }
}

function animate() {
  requestAnimationFrame(animate);
  let dx = 0, dz = 0;
  if (moveForward) { dx += Math.sin(azimuth) * walkSpeed; dz += Math.cos(azimuth) * walkSpeed; }
  if (moveBackward) { dx -= Math.sin(azimuth) * walkSpeed; dz -= Math.cos(azimuth) * walkSpeed; }
  if (moveLeft) { dx += Math.sin(azimuth - Math.PI/2) * walkSpeed; dz += Math.cos(azimuth - Math.PI/2) * walkSpeed; }
  if (moveRight) { dx += Math.sin(azimuth + Math.PI/2) * walkSpeed; dz += Math.cos(azimuth + Math.PI/2) * walkSpeed; }
  if ((moveForward || moveBackward || moveLeft || moveRight) && isRunning) {
    dx *= runSpeed / walkSpeed; dz *= runSpeed / walkSpeed;
  }
  stickman.position.x += dx;
  stickman.position.z += dz;
  if (isJumping || !isGrounded) {
    stickman.position.y += velocityY;
    velocityY -= gravity;
  }
  updateCollisions();
  if (cameraMode !== 3 && (dx !== 0 || dz !== 0)) {
    stickman.rotation.y = Math.atan2(dx, dz);
  }
  let state = "idle";
  if (isJumping || !isGrounded) state = "jump";
  else if (dx !== 0 || dz !== 0) state = isRunning ? "run" : "walk";
  animateStickman(state);
  if (state === "walk" || state === "run") walkCycle += isRunning ? 0.025 : 0.024;
  else walkCycle += 0.012;
  updateCamera();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
