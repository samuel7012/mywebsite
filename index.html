<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WAIT WAIT!</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: absolute; top: 10px; left: 10px;
      color: #fff; background: rgba(0,0,0,0.5);
      padding: 8px; border-radius: 5px;
      font-family: sans-serif;
    }
  </style>
</head>
<body>
<div id="info">
  <b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
  Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
  <b>Arrow keys</b> still use standard mapping<br>
  <b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
  <b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// === YOUR ORIGINAL SETUP ===

let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
let renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Stickman group
let stickman = new THREE.Group();
let material = new THREE.MeshNormalMaterial();
let head = new THREE.Mesh(new THREE.SphereGeometry(0.5), material);
head.position.y = 2.25;
let torso = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1.5), material);
torso.position.y = 1.25;
let legL = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1), material);
legL.position.set(-0.2, 0.5, 0);
let legR = legL.clone(); legR.position.x = 0.2;
let armL = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1), material);
armL.position.set(-0.5, 1.7, 0);
let armR = armL.clone(); armR.position.x = 0.5;
stickman.add(head, torso, legL, legR, armL, armR);
scene.add(stickman);

// Ground
let ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshBasicMaterial({ color: 0x222222 }));
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

// Camera setup
let cameraMode = 1;
camera.position.set(0, 5, 10);
camera.lookAt(0, 1, 0);

// Movement flags
let moveBackward = false, moveForward = false, moveLeft = false, moveRight = false;
let isRunning = false, isJumping = false, isGrounded = true;
let velocityY = 0;
const walkSpeed = 0.08;
const runSpeed = 0.16;
const jumpStrength = 0.24;
const gravity = 0.012;
let walkCycle = 0;

// Input handling
window.addEventListener('keydown', function(e){
  switch(e.key) {
    case 'w': moveBackward = true; break;
    case 's': moveForward = true; break;
    case 'a': moveLeft = true; break;
    case 'd': moveRight = true; break;
    case 'ArrowUp': moveForward = true; break;
    case 'ArrowDown': moveBackward = true; break;
    case 'ArrowLeft': moveLeft = true; break;
    case 'ArrowRight': moveRight = true; break;
    case 'Shift': isRunning = true; break;
    case ' ': 
      if (isGrounded && !isJumping) {
        isJumping = true;
        velocityY = jumpStrength;
      }
      break;
    case '1': cameraMode = 1; break;
    case '2': cameraMode = 2; break;
    case '3': cameraMode = 3; break;
  }
});

window.addEventListener('keyup', function(e){
  switch(e.key) {
    case 'w': moveBackward = false; break;
    case 's': moveForward = false; break;
    case 'a': moveLeft = false; break;
    case 'd': moveRight = false; break;
    case 'ArrowUp': moveForward = false; break;
    case 'ArrowDown': moveBackward = false; break;
    case 'ArrowLeft': moveLeft = false; break;
    case 'ArrowRight': moveRight = false; break;
    case 'Shift': isRunning = false; break;
  }
});

// âœ… FIX: reset movement flags when focus is lost
window.addEventListener('blur', () => {
  moveBackward = false;
  moveForward = false;
  moveLeft = false;
  moveRight = false;
  isRunning = false;
});

let clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  let delta = clock.getDelta();

  // Movement direction
  let dx = 0, dz = 0;
  let speed = isRunning ? runSpeed : walkSpeed;

  if (moveForward) dz += speed;
  if (moveBackward) dz -= speed;
  if (moveLeft) dx -= speed;
  if (moveRight) dx += speed;

  // Clamp micro movement
  if (Math.abs(dx) < 0.0001) dx = 0;
  if (Math.abs(dz) < 0.0001) dz = 0;

  // Walk animation
  if (dx !== 0 || dz !== 0) {
    walkCycle += delta * 10;
    armL.rotation.x = Math.sin(walkCycle) * 0.5;
    armR.rotation.x = -Math.sin(walkCycle) * 0.5;
    legL.rotation.x = -Math.sin(walkCycle) * 0.5;
    legR.rotation.x = Math.sin(walkCycle) * 0.5;
  } else {
    armL.rotation.x = armR.rotation.x = 0;
    legL.rotation.x = legR.rotation.x = 0;
  }

  // Jumping
  if (isJumping) {
    velocityY -= gravity;
    stickman.position.y += velocityY;
    if (stickman.position.y <= 0) {
      stickman.position.y = 0;
      velocityY = 0;
      isJumping = false;
      isGrounded = true;
    }
  }

  // Apply movement
  stickman.position.x += dx;
  stickman.position.z += dz;

  // Camera control
  if (cameraMode === 1) {
    camera.position.set(stickman.position.x, stickman.position.y
