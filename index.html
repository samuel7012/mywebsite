<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Free game</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; }
  #info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; }
</style>
</head>
<body>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/loaders/FontLoader.js';
import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/geometries/TextGeometry.js';

// ===== Scene setup =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ===== Lighting =====
const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
hemiLight.position.set(0, 200, 0);
scene.add(hemiLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(60, 100, -30);
dirLight.castShadow = true;
scene.add(dirLight);

// ===== 3D Text =====
const fontLoader = new FontLoader();
fontLoader.load(
  'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/fonts/helvetiker_regular.typeface.json',
  function(font) {
      const textGeo = new TextGeometry('my coding sucks im 9 yr old', {
          font: font,
          size: 0.5,
          height: 0.2,
          curveSegments: 12,
          bevelEnabled: true,
          bevelThickness: 0.03,
          bevelSize: 0.02,
          bevelSegments: 3
      });
      const textMat = new THREE.MeshStandardMaterial({color: 0xff66cc});
      const textMesh = new THREE.Mesh(textGeo, textMat);
      textMesh.position.set(-3, 4, 0);
      textMesh.rotation.y = -0.3;
      scene.add(textMesh);
  }
);

// ===== Stickman factory =====
function createStickman(color=0xffffff){
  const stickman = new THREE.Group();
  const stickMat = new THREE.MeshStandardMaterial({ color: 0x181818 });
  const headMat = new THREE.MeshStandardMaterial({ color: color });

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 32,32), headMat);
  head.position.y=2.25; stickman.add(head);

  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.95,20), stickMat);
  body.position.y=1.5; stickman.add(body);

  function addLimb(rootPos, upperLen, lowerLen){
    const root = new THREE.Group(); root.position.copy(rootPos); stickman.add(root);

    const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.045,0.045,upperLen,14), stickMat);
    upper.position.y=-upperLen/2; root.add(upper);

    const joint = new THREE.Mesh(new THREE.SphereGeometry(0.06,12,10), stickMat);
    joint.position.y=-upperLen; root.add(joint);

    const lower = new THREE.Group(); lower.position.y=-upperLen;
    const lowerMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.04,lowerLen,12), stickMat);
    lowerMesh.position.y=-lowerLen/2; lower.add(lowerMesh);

    const end = new THREE.Mesh(new THREE.SphereGeometry(0.05,10,8), stickMat);
    end.position.y=-lowerLen; lower.add(end);

    root.add(lower);
    return { root, lower };
  }

  const leftArm = addLimb(new THREE.Vector3(-0.19,1.9,0),0.49,0.42);
  const rightArm = addLimb(new THREE.Vector3(0.19,1.9,0),0.49,0.42);
  const leftLeg = addLimb(new THREE.Vector3(-0.07,0.99,0),0.58,0.49);
  const rightLeg = addLimb(new THREE.Vector3(0.07,0.99,0),0.58,0.49);

  return { model: stickman, head, leftArm:leftArm.root, rightArm:rightArm.root, leftForearm:leftArm.lower, rightForearm:rightArm.lower, leftLeg:leftLeg.root, rightLeg:rightLeg.root, leftShin:leftLeg.lower, rightShin:rightLeg.lower };
}

// ===== Multiplayer state =====
const playerId = Math.random().toString(36).substr(2,9);
const players = {};
function addPlayer(id,color){
  if(!players[id]){
    const parts = createStickman(color);
    scene.add(parts.model);
    players[id] = { ...parts, x:0, y:0, z:0, facing:0, movement:{running:false,jumping:false,grounded:true,velocityY:0}, walkCycle:0, state:"idle", color };
  }
}
addPlayer(playerId,0xffffff);

// ===== Controls =====
let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
let isRunning=false, isJumping=false, isGrounded=true;
const walkSpeed=0.08, runSpeed=0.16, jumpStrength=0.24;

window.addEventListener('keydown', e=>{
  switch(e.key){
    case 'w': moveForward=true; break;
    case 's': moveBackward=true; break;
    case 'a': moveLeft=true; break;
    case 'd': moveRight=true; break;
    case 'Shift': isRunning=true; break;
    case ' ':
      if(isGrounded && !isJumping){ isJumping=true; } break;
  }
});
window.addEventListener('keyup', e=>{
  switch(e.key){
    case 'w': moveForward=false; break;
    case 's': moveBackward=false; break;
    case 'a': moveLeft=false; break;
    case 'd': moveRight=false; break;
    case 'Shift': isRunning=false; break;
  }
});

// ===== Camera orbit =====
let azimuth=0, polar=Math.PI/5, radius=8;
let lastMouse={x:0,y:0}, mouseInitialized=false;
const mouseSensitivity=0.005;

document.addEventListener('mousemove',e=>{
  if(!mouseInitialized){ lastMouse={x:e.clientX,y:e.clientY}; mouseInitialized=true; return; }
  const dx=e.clientX-lastMouse.x, dy=e.clientY-lastMouse.y;
  azimuth-=dx*mouseSensitivity; polar-=dy*mouseSensitivity;
  polar=Math.max(0.1, Math.min(Math.PI/2-0.05, polar));
  lastMouse={x:e.clientX, y:e.clientY};
});
document.addEventListener('mouseleave',()=>mouseInitialized=false);
renderer.domElement.addEventListener('wheel', e=>{ radius+=e.deltaY*0.01; radius=Math.max(2, Math.min(30, radius)); });

// ===== Main loop =====
function animate(){
  requestAnimationFrame(animate);

  const player = players[playerId];

  // Camera follow
  const camX = player.x + radius*Math.sin(polar)*Math.sin(azimuth);
  const camY = player.y + radius*Math.cos(polar)+1;
  const camZ = player.z + radius*Math.sin(polar)*Math.cos(azimuth);
  camera.position.set(camX, camY, camZ);
  camera.lookAt(player.x, player.y+1.4, player.z);

  renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
