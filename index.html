<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Stickman Lumpy Grass World</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; }
  #info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; width:98%; height:11%; }
  #spawnButton { position: absolute; top: 20px; left: 20px; z-index:1000; padding:8px 12px; font-size:16px; background:#0077ff; color:#fff; border:none; border-radius:6px; cursor:pointer; }
</style>
</head>
<body>
<div id="info">
  <marquee direction="right">
    <ol style="margin:0; padding:0; list-style:decimal inside; display:inline-flex; gap:15px;">
      <li><b>W</b>: forward</li>
      <li><b>S</b>: backward</li>
      <li><b>A</b>: left</li>
      <li><b>D</b>: right</li>
    </ol>
    &nbsp;| Hold <b>Shift</b> to run, <b>Space</b> to jump |
    Move mouse to rotate camera, scroll to zoom |
    Multiplayer stickman demo!
  </marquee>
</div>

<button id="spawnButton">Spawn Grass World</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// ===== Scene setup =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// ===== Stickman Factory =====
function createStickman(color=0xffffff) {
  const stickman = new THREE.Group();
  const stickMat = new THREE.MeshStandardMaterial({color: 0x181818});
  const headMat = new THREE.MeshStandardMaterial({color: color});

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 32, 32), headMat);
  head.position.y = 2.25;
  stickman.add(head);

  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.95, 20), stickMat);
  body.position.y = 1.5;
  stickman.add(body);

  function addLimb(rootPos, upperLen, lowerLen) {
    const root = new THREE.Group();
    root.position.copy(rootPos);
    stickman.add(root);

    const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, upperLen, 14), stickMat);
    upper.position.y = -upperLen/2;
    root.add(upper);

    const joint = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 10), stickMat);
    joint.position.y = -upperLen;
    root.add(joint);

    const lower = new THREE.Group();
    lower.position.y = -upperLen;
    const lowerMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, lowerLen, 12), stickMat);
    lowerMesh.position.y = -lowerLen/2;
    lower.add(lowerMesh);

    const end = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 8), stickMat);
    end.position.y = -lowerLen;
    lower.add(end);

    root.add(lower);
    return {root, lower};
  }

  const leftArm = addLimb(new THREE.Vector3(-0.19, 1.9, 0), 0.49, 0.42);
  const rightArm = addLimb(new THREE.Vector3(0.19, 1.9, 0), 0.49, 0.42);
  const leftLeg = addLimb(new THREE.Vector3(-0.07, 0.99, 0), 0.58, 0.49);
  const rightLeg = addLimb(new THREE.Vector3(0.07, 0.99, 0), 0.58, 0.49);

  return {
    model: stickman,
    head,
    leftArm: leftArm.root, rightArm: rightArm.root,
    leftForearm: leftArm.lower, rightForearm: rightArm.lower,
    leftLeg: leftLeg.root, rightLeg: rightLeg.root,
    leftShin: leftLeg.lower, rightShin: rightLeg.lower
  };
}

// ===== Multiplayer state =====
const playerId = Math.random().toString(36).substr(2, 9);
const players = {};
const npcs = [];

function addPlayer(id, color) {
  if (!players[id]) {
    const parts = createStickman(color);
    scene.add(parts.model);
    players[id] = {
      ...parts,
      x: 0, y: 0, z: 0,
      facing: 0,
      targetX:0, targetY:0, targetZ:0,
      movement: {running:false, jumping:false, grounded:true, velocityY:0},
      walkCycle: 0,
      state: "idle",
      color
    };
  }
}

// Local player
addPlayer(playerId, 0xffffff);

// ===== Ground + Grass on button click =====
let ground, grassField;

function groundHeight(x, z) {
  return (Math.sin(x*0.2) + Math.cos(z*0.3)) * 0.6;
}

function createGroundAndGrass() {
  // Bumpy ground
  const groundGeo = new THREE.PlaneGeometry(200, 200, 100, 100);
  for (let i = 0; i < groundGeo.attributes.position.count; i++) {
    const x = groundGeo.attributes.position.getX(i);
    const z = groundGeo.attributes.position.getY(i);
    const y = groundHeight(x, z);
    groundGeo.attributes.position.setZ(i, y);
  }
  groundGeo.computeVertexNormals();

  const groundMat = new THREE.MeshStandardMaterial({ color: 0x5a3e2b });
  ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;

  // Grass
  const grassGroup = new THREE.Group();
  for (let i = 0; i < 12000; i++) {
    const x = (Math.random()-0.5)*180;
    const z = (Math.random()-0.5)*180;
    const y = groundHeight(x, z)+0.05;

    const geo = new THREE.ConeGeometry(0.15,0.4,3);
    const mat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
    const blade = new THREE.Mesh(geo, mat);
    blade.rotation.x = -Math.PI/2;
    blade.position.set(x,y,z);
    grassGroup.add(blade);
  }
  grassField = grassGroup;

  scene.add(ground);
  scene.add(grassField);
}

// Button listener
document.getElementById("spawnButton").addEventListener("click", ()=>{
  if(!ground && !grassField){
    createGroundAndGrass();
    document.getElementById("spawnButton").style.display="none"; // hide button after spawn
  }
});

// ===== Camera orbit =====
let azimuth=0, polar=Math.PI/5, radius=8;
const minPolar=0.1, maxPolar=Math.PI/2-0.05;
let lastMouse={x:0,y:0}, mouseInitialized=false;
const mouseSensitivity=0.005;

document.addEventListener('mousemove', e=>{
  if(!mouseInitialized){ lastMouse={x:e.clientX,y:e.clientY}; mouseInitialized=true; return; }
  let dx=e.clientX-lastMouse.x, dy=e.clientY-lastMouse.y;
  azimuth -= dx*mouseSensitivity; polar -= dy*mouseSensitivity;
  polar = Math.max(minPolar, Math.min(maxPolar, polar));
  lastMouse={x:e.clientX, y:e.clientY};
});
document.addEventListener('mouseleave', ()=>mouseInitialized=false);
renderer.domElement.addEventListener('wheel', e=>{
  radius += e.deltaY*0.01; radius=Math.max(2, Math.min(30, radius));
});
function updateCamera(target){
  let camX=target.x+radius*Math.sin(polar)*Math.sin(azimuth);
  let camY=target.y+radius*Math.cos(polar)+1;
  let camZ=target.z+radius*Math.sin(polar)*Math.cos(azimuth);
  camera.position.set(camX, camY, camZ);
  camera.lookAt(target.x, target.y+1.4, target.z);
}

// ===== Movement =====
let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
let isRunning=false, isJumping=false, isGrounded=true;
let velocityY=0;
const walkSpeed=0.08, runSpeed=0.16, jumpStrength=0.24, gravity=0.012;

window.addEventListener('keydown', e=>{
  switch(e.key){
    case 's': moveForward=true; break;
    case 'w': moveBackward=true; break;
    case 'a': moveLeft=true; break;
    case 'd': moveRight=true; break;
    case 'Shift': isRunning=true; break;
    case ' ': if(isGrounded && !isJumping){ isJumping=true; velocityY=jumpStrength; } break;
  }
});
window.addEventListener('keyup', e=>{
  switch(e.key){
    case 's': moveForward=false; break;
    case 'w': moveBackward=false; break;
    case 'a': moveLeft=false; break;
    case 'd': moveRight=false; break;
    case 'Shift': isRunning=false; break;
  }
});

// ===== Stickman animation placeholder =====
function animateStickman(player, dt){}

// ===== Main loop =====
let prevTime = performance.now();
function animate(){
  requestAnimationFrame(animate);
  let time = performance.now();
  let dt = Math.min((time-prevTime)/1000,0.05);
  prevTime = time;

  const player = players[playerId];
  let dx=0,dz=0;
  let speed = isRunning?runSpeed:walkSpeed;
  if(moveForward){ dx+=Math.sin(azimuth)*speed; dz+=Math.cos(azimuth)*speed; }
  if(moveBackward){ dx-=Math.sin(azimuth)*speed; dz-=Math.cos(azimuth)*speed; }
  if(moveLeft){ dx+=Math.sin(azimuth-Math.PI/2)*speed; dz+=Math.cos(azimuth-Math.PI/2)*speed; }
  if(moveRight){ dx+=Math.sin(azimuth+Math.PI/2)*speed; dz+=Math.cos(azimuth+Math.PI/2)*speed; }

  player.x += dx; player.z += dz;
  if(isJumping||!isGrounded){
    player.y += velocityY;
    velocityY -= gravity;
    if(player.y<=0){ player.y=0; velocityY=0; isJumping=false; isGrounded=true; }
    else{ isGrounded=false; }
  }

  player.model.position.set(player.x,player.y,player.z);
  if(dx!==0||dz!==0){ player.facing=Math.atan2(dx,dz); player.model.rotation.y=player.facing; }

  updateCamera(player);
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
