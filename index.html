<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Animated 3D Stickman Game (Arms Not Crossed)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; }
  </style>
</head>
<body>
  <div id="info">
    <b>WASD/Arrow keys</b>: walk<br>
    <b>Shift</b>: run &nbsp; <b>Space</b>: jump<br>
    <b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down<br>
    <b>Move mouse</b>: rotate camera, <b>Scroll</b>: zoom
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script>
    // === SCENE SETUP ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222233);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 4, 8);

    let cameraMode = 1;

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

    // Ground
    const groundGeometry = new THREE.PlaneGeometry(40, 40);
    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // === STICKMAN MODEL ===
    const stickman = new THREE.Group();
    const stickMat = new THREE.MeshStandardMaterial({color: 0x222222});
    const headMat = new THREE.MeshStandardMaterial({color: 0xffffff});

    // Head
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 32, 32), headMat);
    head.position.y = 2.2;
    stickman.add(head);

    // Body (spine)
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.8, 12), stickMat);
    body.position.y = 1.7;
    stickman.add(body);

    // Shoulders
    const shoulders = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.4, 12), stickMat);
    shoulders.position.y = 2.05;
    shoulders.rotation.z = Math.PI/2;
    stickman.add(shoulders);

    // Hips
    const hips = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.3, 12), stickMat);
    hips.position.y = 1.3;
    hips.rotation.z = Math.PI/2;
    stickman.add(hips);

    // --- Arms: slightly down, slightly forward, NOT crossed ---
    // We'll create each limb as a group for easy animation

    // LEFT ARM
    const leftArm = new THREE.Group();
    leftArm.position.set(-0.28, 1.98, 0); // moved outward more
    leftArm.rotation.x = -Math.PI/16; // slightly forward
    leftArm.rotation.z = Math.PI/6;   // 30deg down from horizontal

    const upperArmL = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8), stickMat);
    upperArmL.position.y = -0.25;
    leftArm.add(upperArmL);

    const leftForearm = new THREE.Group();
    leftForearm.position.y = -0.5;
    const lowerArmL = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.45, 8), stickMat);
    lowerArmL.position.y = -0.225;
    leftForearm.add(lowerArmL);
    leftArm.add(leftForearm);
    stickman.add(leftArm);

    // RIGHT ARM
    const rightArm = new THREE.Group();
    rightArm.position.set(0.28, 1.98, 0); // moved outward more
    rightArm.rotation.x = -Math.PI/16; // slightly forward
    rightArm.rotation.z = -Math.PI/6;  // 30deg down from horizontal

    const upperArmR = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8), stickMat);
    upperArmR.position.y = -0.25;
    rightArm.add(upperArmR);

    const rightForearm = new THREE.Group();
    rightForearm.position.y = -0.5;
    const lowerArmR = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.45, 8), stickMat);
    lowerArmR.position.y = -0.225;
    rightForearm.add(lowerArmR);
    rightArm.add(rightForearm);
    stickman.add(rightArm);

    // LEFT LEG
    const leftLeg = new THREE.Group();
    leftLeg.position.set(-0.09, 1.02, 0);
    const upperLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.55, 8), stickMat);
    upperLegL.position.y = -0.275;
    leftLeg.add(upperLegL);

    const leftShin = new THREE.Group();
    leftShin.position.y = -0.55;
    const lowerLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8), stickMat);
    lowerLegL.position.y = -0.25;
    leftShin.add(lowerLegL);
    leftLeg.add(leftShin);
    stickman.add(leftLeg);

    // RIGHT LEG
    const rightLeg = new THREE.Group();
    rightLeg.position.set(0.09, 1.02, 0);
    const upperLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.55, 8), stickMat);
    upperLegR.position.y = -0.275;
    rightLeg.add(upperLegR);

    const rightShin = new THREE.Group();
    rightShin.position.y = -0.55;
    const lowerLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8), stickMat);
    lowerLegR.position.y = -0.25;
    rightShin.add(lowerLegR);
    rightLeg.add(rightShin);
    stickman.add(rightLeg);

    scene.add(stickman);

    // === ANIMATION STATE ===
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let isRunning = false, isJumping = false, isGrounded = true;
    let velocityY = 0;
    const walkSpeed = 0.08;
    const runSpeed = 0.16;
    const jumpStrength = 0.25;
    const gravity = 0.012;
    let stickmanY = 0;
    let walkCycle = 0;

    window.addEventListener('keydown', function(e){
      switch(e.key) {
        case 'w':
        case 'ArrowUp': moveForward = true; break;
        case 's':
        case 'ArrowDown': moveBackward = true; break;
        case 'a':
        case 'ArrowLeft': moveLeft = true; break;
        case 'd':
        case 'ArrowRight': moveRight = true; break;
        case 'Shift': isRunning = true; break;
        case ' ':
          if (isGrounded && !isJumping) {
            isJumping = true;
            velocityY = jumpStrength;
          }
          break;
        case '1': cameraMode = 1; break;
        case '2': cameraMode = 2; break;
        case '3': cameraMode = 3; break;
      }
    });
    window.addEventListener('keyup', function(e){
      switch(e.key) {
        case 'w':
        case 'ArrowUp': moveForward = false; break;
        case 's':
        case 'ArrowDown': moveBackward = false; break;
        case 'a':
        case 'ArrowLeft': moveLeft = false; break;
        case 'd':
        case 'ArrowRight': moveRight = false; break;
        case 'Shift': isRunning = false; break;
      }
    });

    // === CAMERA CONTROLS ===
    let azimuth = 0;
    let polar = Math.PI/5;
    let radius = 8;
    const minPolar = 0.1;
    const maxPolar = Math.PI/2 - 0.05;
    let lastMouse = {x: window.innerWidth/2, y: window.innerHeight/2};
    let mouseInitialized = false;
    const mouseSensitivity = 0.005;

    document.addEventListener('mousemove', function(e){
      if (cameraMode === 2) return;
      if (!mouseInitialized) {
        lastMouse.x = e.clientX; lastMouse.y = e.clientY;
        mouseInitialized = true;
        return;
      }
      let dx = e.clientX - lastMouse.x;
      let dy = e.clientY - lastMouse.y;
      azimuth -= dx * mouseSensitivity;
      polar -= dy * mouseSensitivity;
      polar = Math.max(minPolar, Math.min(maxPolar, polar));
      lastMouse.x = e.clientX;
      lastMouse.y = e.clientY;
    });

    document.addEventListener('mouseleave', function(){
      mouseInitialized = false;
    });

    renderer.domElement.addEventListener('wheel', function(e){
      if (cameraMode === 2) return;
      radius += e.deltaY * 0.01;
      radius = Math.max(2, Math.min(30, radius));
    });

    // === ANIMATION LOGIC ===
    function animateStickman(dt, state) {
      const t = walkCycle;
      let armRest = Math.PI/6; // arms slightly down
      let forearmRest = 0;
      // Animate upper arms (z) and forearms (z), legs (x) and shins (x)
      if(state==="idle") {
        leftArm.rotation.z = armRest + Math.sin(t*1.5)*0.07;
        rightArm.rotation.z = -armRest - Math.sin(t*1.5)*0.07;
        leftForearm.rotation.z = 0;
        rightForearm.rotation.z = 0;
        leftLeg.rotation.x = 0;
        rightLeg.rotation.x = 0;
        leftShin.rotation.x = 0;
        rightShin.rotation.x = 0;
      }
      else if(state==="walk" || state==="run") {
        let freq = state==="walk"? 5 : 10;
        let amplitude = state==="walk"? 0.6 : 1.0;
        let foreamp = state==="walk"? 0.3 : 0.5;
        let shinamp = state==="walk"? 0.5 : 0.85;
        let phase = t*freq;
        leftArm.rotation.z = armRest + Math.sin(phase)*amplitude*0.4;
        rightArm.rotation.z = -armRest + Math.sin(phase+Math.PI)*amplitude*0.4;
        leftForearm.rotation.z = Math.max(0, Math.sin(phase)*foreamp);
        rightForearm.rotation.z = Math.max(0, Math.sin(phase+Math.PI)*foreamp);
        leftLeg.rotation.x = Math.sin(phase)*amplitude*0.5;
        rightLeg.rotation.x = Math.sin(phase+Math.PI)*amplitude*0.5;
        leftShin.rotation.x = Math.max(0, -Math.sin(phase+Math.PI/4))*shinamp;
        rightShin.rotation.x = Math.max(0, -Math.sin(phase+Math.PI/4+Math.PI))*shinamp;
      }
      else if(state==="jump") {
        leftArm.rotation.z = armRest - 1.0;
        rightArm.rotation.z = -armRest + 1.0;
        leftForearm.rotation.z = -0.6;
        rightForearm.rotation.z = 0.6;
        leftLeg.rotation.x = 0.7;
        rightLeg.rotation.x = 0.7;
        leftShin.rotation.x = 0.7;
        rightShin.rotation.x = 0.7;
      }
    }

    // === UPDATE LOOP ===
    function animate() {
      requestAnimationFrame(animate);

      // Movement vector
      let moveVec = new THREE.Vector3();
      if(moveForward) moveVec.z -= 1;
      if(moveBackward) moveVec.z += 1;
      if(moveLeft) moveVec.x -= 1;
      if(moveRight) moveVec.x += 1;
      if(moveVec.lengthSq() > 0) moveVec.normalize();

      // Stickman rotation: face movement direction (except top-down view)
      if(cameraMode !== 3 && moveVec.lengthSq() > 0) {
        let theta = azimuth;
        let moveAngle = Math.atan2(moveVec.x, moveVec.z);
        stickman.rotation.y = theta + moveAngle;
      }

      // Speed
      let moveSpeed = isRunning ? runSpeed : walkSpeed;
      if(isGrounded) {
        stickman.position.x += Math.sin(stickman.rotation.y) * moveVec.z * moveSpeed;
        stickman.position.z += Math.cos(stickman.rotation.y) * moveVec.z * moveSpeed;
        stickman.position.x += Math.cos(stickman.rotation.y) * moveVec.x * moveSpeed;
        stickman.position.z -= Math.sin(stickman.rotation.y) * moveVec.x * moveSpeed;
      }

      // Jumping/Gravity
      if(isJumping || !isGrounded) {
        stickman.position.y += velocityY;
        velocityY -= gravity;
        if(stickman.position.y <= 0) {
          stickman.position.y = 0;
          isJumping = false;
          isGrounded = true;
          velocityY = 0;
        } else {
          isGrounded = false;
        }
      } else {
        stickman.position.y = 0;
      }

      // Animation state
      let state = "idle";
      if(isJumping || !isGrounded) state = "jump";
      else if(moveVec.lengthSq() > 0) state = isRunning ? "run" : "walk";
      animateStickman(0.016, state);

      // Animate walk cycle
      if(state === "walk" || state === "run") walkCycle += (isRunning ? 0.17 : 0.08);
      else walkCycle += 0.015;

      // Camera update
      if (cameraMode === 1) {
        let camX = stickman.position.x + radius * Math.sin(polar) * Math.sin(azimuth);
        let camY = stickman.position.y + radius * Math.cos(polar) + 1.2;
        let camZ = stickman.position.z + radius * Math.sin(polar) * Math.cos(azimuth);
        camera.position.set(camX, camY, camZ);
        camera.lookAt(stickman.position.x, stickman.position.y+1.3, stickman.position.z);
      } else if (cameraMode === 2) {
        camera.position.x = stickman.position.x;
        camera.position.y = stickman.position.y + 2.2;
        camera.position.z = stickman.position.z + 0.2;
        camera.lookAt(
          stickman.position.x,
          stickman.position.y + 2.2,
          stickman.position.z + 2
        );
      } else if (cameraMode === 3) {
        let camX = stickman.position.x + radius * Math.sin(azimuth);
        let camY = stickman.position.y + 15;
        let camZ = stickman.position.z + radius * Math.cos(azimuth);
        camera.position.set(camX, camY, camZ);
        camera.lookAt(stickman.position.x, stickman.position.y, stickman.position.z);
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
