<html lang="en">
<head>
<meta charset="UTF-8">
  <title>does this work?</title>
<style>
body { margin: 0; overflow: hidden; }
#info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; }
</style>
</head>
<body>
<div id="info">
<b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
<b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom<br>
Multiplayer stickman demo!
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);

let cameraMode = 1; // only third-person used here

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Ground
const groundGeometry = new THREE.PlaneGeometry(60, 60);
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x696969 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// Stickman factory (returns model and references to limbs for animation)
function createStickman(color=0xffffff) {
  const stickman = new THREE.Group();

  const stickMat = new THREE.MeshStandardMaterial({color: 0x181818});
  const headMat = new THREE.MeshStandardMaterial({color: color});

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 32, 32), headMat);
  head.position.y = 2.25;
  stickman.add(head);

  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.95, 20), stickMat);
  body.position.y = 1.5;
  stickman.add(body);

  const shoulders = new THREE.Mesh(new THREE.SphereGeometry(0.09, 20, 16), stickMat);
  shoulders.position.y = 1.98;
  stickman.add(shoulders);

  const hips = new THREE.Mesh(new THREE.SphereGeometry(0.085, 18, 12), stickMat);
  hips.position.y = 1.02;
  stickman.add(hips);

  // -- Left Arm --
  const leftArm = new THREE.Group();
  leftArm.position.set(-0.19, 1.9, 0);
  stickman.add(leftArm);
  const upperArmL = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14), stickMat);
  upperArmL.position.y = -0.245;
  leftArm.add(upperArmL);
  const elbowL = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 10), stickMat);
  elbowL.position.y = -0.49;
  leftArm.add(elbowL);
  const leftForearm = new THREE.Group();
  leftForearm.position.y = -0.49;
  const lowerArmL = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12), stickMat);
  lowerArmL.position.y = -0.21;
  leftForearm.add(lowerArmL);
  const handL = new THREE.Mesh(new THREE.SphereGeometry(0.045, 10, 8), stickMat);
  handL.position.y = -0.42;
  leftForearm.add(handL);
  leftArm.add(leftForearm);

  // -- Right Arm --
  const rightArm = new THREE.Group();
  rightArm.position.set(0.19, 1.9, 0);
  stickman.add(rightArm);
  const upperArmR = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14), stickMat);
  upperArmR.position.y = -0.245;
  rightArm.add(upperArmR);
  const elbowR = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 10), stickMat);
  elbowR.position.y = -0.49;
  rightArm.add(elbowR);
  const rightForearm = new THREE.Group();
  rightForearm.position.y = -0.49;
  const lowerArmR = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12), stickMat);
  lowerArmR.position.y = -0.21;
  rightForearm.add(lowerArmR);
  const handR = new THREE.Mesh(new THREE.SphereGeometry(0.045, 10, 8), stickMat);
  handR.position.y = -0.42;
  rightForearm.add(handR);
  rightArm.add(rightForearm);

  // -- Left Leg --
  const leftLeg = new THREE.Group();
  leftLeg.position.set(-0.07, 0.99, 0);
  stickman.add(leftLeg);
  const upperLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14), stickMat);
  upperLegL.position.y = -0.29;
  leftLeg.add(upperLegL);
  const kneeL = new THREE.Mesh(new THREE.SphereGeometry(0.07, 12, 8), stickMat);
  kneeL.position.y = -0.58;
  leftLeg.add(kneeL);
  const leftShin = new THREE.Group();
  leftShin.position.y = -0.58;
  const lowerLegL = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12), stickMat);
  lowerLegL.position.y = -0.245;
  leftShin.add(lowerLegL);
  const footL = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 8), stickMat);
  footL.position.y = -0.49;
  leftShin.add(footL);
  leftLeg.add(leftShin);

  // -- Right Leg --
  const rightLeg = new THREE.Group();
  rightLeg.position.set(0.07, 0.99, 0);
  stickman.add(rightLeg);
  const upperLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14), stickMat);
  upperLegR.position.y = -0.29;
  rightLeg.add(upperLegR);
  const kneeR = new THREE.Mesh(new THREE.SphereGeometry(0.07, 12, 8), stickMat);
  kneeR.position.y = -0.58;
  rightLeg.add(kneeR);
  const rightShin = new THREE.Group();
  rightShin.position.y = -0.58;
  const lowerLegR = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12), stickMat);
  lowerLegR.position.y = -0.245;
  rightShin.add(lowerLegR);
  const footR = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 8), stickMat);
  footR.position.y = -0.49;
  rightShin.add(footR);
  rightLeg.add(rightShin);

  return {
    model: stickman,
    head, leftArm, rightArm,
    leftForearm, rightForearm,
    leftLeg, rightLeg,
    leftShin, rightShin
  };
}

// Multiplayer player state
const playerId = Math.random().toString(36).substr(2, 9);
const players = {}; // id: {model, ...limb refs, x, y, z, facing, movement, ...animation}
function addPlayer(id, color=0xffffff) {
  if (!players[id]) {
    const stickmanParts = createStickman(color);
    scene.add(stickmanParts.model);
    players[id] = {
      ...stickmanParts,
      x: 0, y: 0, z: 0,
      facing: 0,
      movement: {dx:0, dz:0, running:false, jumping:false, grounded:true, velocityY:0},
      walkCycle: 0,
      state: "idle"
    };
  }
}
function updatePlayerPosition(id, x, y, z, facing, movementState) {
  if (players[id]) {
    players[id].x = x;
    players[id].y = y;
    players[id].z = z;
    players[id].model.position.set(x, y, z);
    players[id].model.rotation.y = facing;
    players[id].state = movementState;
  }
}
function removePlayer(id) {
  if (players[id]) {
    scene.remove(players[id].model);
    delete players[id];
  }
}

// Add local player
addPlayer(playerId, 0xffffff);

// Movement state (local)
let moveBackward = false, moveForward = false, moveLeft = false, moveRight = false;
let isRunning = false;
let isJumping = false;
let isGrounded = true;
let velocityY = 0;
const walkSpeed = 0.08;
const runSpeed = 0.16;
const jumpStrength = 0.24;
const gravity = 0.012;
let walkCycle = 0;

window.addEventListener('keydown', function(e){
switch(e.key) {
case 'w': moveBackward = true; break;
case 's': moveForward = true; break;
case 'a': moveLeft = true; break;
case 'd': moveRight = true; break;
case 'Shift': isRunning = true; break;
case ' ': 
if (isGrounded && !isJumping) {
isJumping = true;
velocityY = jumpStrength;
}
break;
}
});
window.addEventListener('keyup', function(e){
switch(e.key) {
case 'w': moveBackward = false; break;
case 's': moveForward = false; break;
case 'a': moveLeft = false; break;
case 'd': moveRight = false; break;
case 'Shift': isRunning = false; break;
}
});

// Mouse orbit controls
let azimuth = 0;
let polar = Math.PI/5;
let radius = 8;
const minPolar = 0.1;
const maxPolar = Math.PI/2 - 0.05;
let lastMouse = {x: window.innerWidth/2, y: window.innerHeight/2};
let mouseInitialized = false;
const mouseSensitivity = 0.005;

document.addEventListener('mousemove', function(e){
if (!mouseInitialized) {
lastMouse.x = e.clientX; lastMouse.y = e.clientY;
mouseInitialized = true;
return;
}
let dx = e.clientX - lastMouse.x;
let dy = e.clientY - lastMouse.y;
azimuth -= dx * mouseSensitivity;
polar -= dy * mouseSensitivity;
polar = Math.max(minPolar, Math.min(maxPolar, polar));
lastMouse.x = e.clientX;
lastMouse.y = e.clientY;
});
document.addEventListener('mouseleave', function(){ mouseInitialized = false; });
renderer.domElement.addEventListener('wheel', function(e){
radius += e.deltaY * 0.01;
radius = Math.max(2, Math.min(30, radius));
});
function updateCamera(target) {
  let camX = target.x + radius * Math.sin(polar) * Math.sin(azimuth);
  let camY = target.y + radius * Math.cos(polar) + 1;
  let camZ = target.z + radius * Math.sin(polar) * Math.cos(azimuth);
  camera.position.set(camX, camY, camZ);
  camera.lookAt(target.x, target.y + 1.4, target.z);
}

// Animate stickman limbs
function animateStickman(player, dt) {
  let t = player.walkCycle;
  let leftArm = player.leftArm, rightArm = player.rightArm;
  let leftForearm = player.leftForearm, rightForearm = player.rightForearm;
  let leftLeg = player.leftLeg, rightLeg = player.rightLeg;
  let leftShin = player.leftShin, rightShin = player.rightShin;
  let state = player.state;
  if (state === "idle") {
    leftArm.rotation.x = 0; rightArm.rotation.x = 0;
    leftForearm.rotation.x = 0; rightForearm.rotation.x = 0;
    leftLeg.rotation.x = 0; rightLeg.rotation.x = 0;
    leftShin.rotation.x = 0; rightShin.rotation.x = 0;
  } else if (state === "walk") {
    let freq = 5, ampArm = 0.65, ampLeg = 0.7, shinamp = 0.47, phase = t * freq;
    leftArm.rotation.x = Math.sin(phase) * ampArm;
    rightArm.rotation.x = Math.sin(phase + Math.PI) * ampArm;
    leftForearm.rotation.x = 0; rightForearm.rotation.x = 0;
    leftLeg.rotation.x = Math.sin(phase) * ampLeg;
    rightLeg.rotation.x = Math.sin(phase + Math.PI) * ampLeg;
    leftShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4)) * shinamp;
    rightShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4 + Math.PI)) * shinamp;
    player.walkCycle += dt * (player.movement.running ? 1.04 : 1);
  } else if (state === "run") {
    let freq = 9.5, ampArm = 1.6, ampLeg = 1.8, shinamp = 1.35, phase = t * freq;
    leftArm.rotation.x = Math.sin(phase) * ampArm * 0.6;
    rightArm.rotation.x = Math.sin(phase + Math.PI) * ampArm * 0.6;
    leftForearm.rotation.x = Math.abs(Math.sin(phase)) * 0.9 - 1.1;
    rightForearm.rotation.x = Math.abs(Math.sin(phase + Math.PI)) * 0.9 - 1.1;
    leftLeg.rotation.x = Math.sin(phase) * ampLeg;
    rightLeg.rotation.x = Math.sin(phase + Math.PI) * ampLeg;
    leftShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 6)) * shinamp + 0.13 * Math.abs(Math.sin(phase));
    rightShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 6 + Math.PI)) * shinamp + 0.13 * Math.abs(Math.sin(phase + Math.PI));
    player.walkCycle += dt * 1.3;
  } else if (state === "jump") {
    leftArm.rotation.x = -1.15; rightArm.rotation.x = -1.15;
    leftForearm.rotation.x = -0.42; rightForearm.rotation.x = -0.42;
    leftLeg.rotation.x = 0.88; rightLeg.rotation.x = 0.88;
    leftShin.rotation.x = 0.8; rightShin.rotation.x = 0.8;
    player.walkCycle += dt * 0.6;
  } else {
    player.walkCycle += dt * 0.6;
  }
}

// Multiplayer networking (DEMO)
// Replace with your own WebSocket server for real multiplayer!
const ws = new WebSocket("https://samuelvaldez.website/"); // echo server for demo
ws.onopen = () => {
  ws.send(JSON.stringify({join: playerId, color: 0xffffff}));
};
ws.onmessage = (msg) => {
  const data = JSON.parse(msg.data);
  if (data.join && data.join !== playerId) {
    addPlayer(data.join, data.color || 0xff44ff);
  }
  if (data.move && data.id !== playerId) {
    updatePlayerPosition(data.id, data.x, data.y, data.z, data.facing, data.movementState);
  }
  if (data.leave && data.leave !== playerId) {
    removePlayer(data.leave);
  }
};
window.addEventListener('beforeunload', () => {
  ws.send(JSON.stringify({leave: playerId}));
});

// Animation loop
let prevTime = performance.now();
function animate() {
  requestAnimationFrame(animate);
  let time = performance.now();
  let dt = Math.min((time - prevTime) / 1000, 0.05);
  prevTime = time;

  // Local player movement
  let dx = 0, dz = 0;
  if (moveForward) { dx += Math.sin(azimuth) * walkSpeed; dz += Math.cos(azimuth) * walkSpeed; }
  if (moveBackward) { dx -= Math.sin(azimuth) * walkSpeed; dz -= Math.cos(azimuth) * walkSpeed; }
  if (moveLeft) { dx += Math.sin(azimuth - Math.PI/2) * walkSpeed; dz += Math.cos(azimuth - Math.PI/2) * walkSpeed; }
  if (moveRight){ dx += Math.sin(azimuth + Math.PI/2) * walkSpeed; dz += Math.cos(azimuth + Math.PI/2) * walkSpeed; }
  if ((moveForward || moveBackward || moveLeft || moveRight) && isRunning) {
    dx *= runSpeed / walkSpeed;
    dz *= runSpeed / walkSpeed;
  }

  const player = players[playerId];
  player.x += dx;
  player.z += dz;

  // Simple jump & gravity
  if (isJumping || !isGrounded) {
    player.y += velocityY;
    velocityY -= gravity;
    if (player.y <= 0) {
      player.y = 0;
      velocityY = 0;
      isJumping = false;
      isGrounded = true;
    } else {
      isGrounded = false;
    }
  } else {
    if (player.y <= 0) {
      player.y = 0;
      isGrounded = true;
    }
  }

  player.model.position.set(player.x, player.y, player.z);

  // Face direction of movement
  if (dx !== 0 || dz !== 0) {
    player.facing = Math.atan2(dx, dz);
    player.model.rotation.y = player.facing;
  }

  // Animation state
  let state = "idle";
  if(isJumping || !isGrounded) state = "jump";
  else if(dx !== 0 || dz !== 0) state = isRunning ? "run" : "walk";
  player.state = state;

  animateStickman(player, dt);

  // Send local player position and animation state to server
  if (ws.readyState === 1) {
    ws.send(JSON.stringify({
      move: true, id: playerId,
      x: player.x, y: player.y, z: player.z,
      facing: player.facing,
      movementState: player.state
    }));
  }

  // Animate remote stickmen
  for (const [id, remotePlayer] of Object.entries(players)) {
    if (id !== playerId) {
      animateStickman(remotePlayer, dt);
    }
  }

  updateCamera(player);

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', function() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
