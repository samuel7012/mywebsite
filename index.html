<html lang="en">
<head>
<meta charset="UTF-8">
  <title> :)</title>
<style>
body { margin: 0; overflow: hidden; }
#info { position: absolute; top: 10px; left: 10px; color: #fff; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 5px; font-family: sans-serif; }
</style>
</head>
<body>
<div id="info" style="display:none">
<b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
<b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down view<br>
<b>Move mouse</b> to rotate camera, <b>Scroll</b> to zoom (except first-person)
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
  
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);

let cameraMode = 1; // 1: third-person, 2: first-person, 3: top-down

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Ground
const groundGeometry = new THREE.PlaneGeometry(100, 100);
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// Grass
const grassGeometry = new THREE.PlaneGeometry(0.1, 1);
const grassMaterial = new THREE.MeshStandardMaterial({
  color: 0x228833,
  side: THREE.DoubleSide
});

const grassCount = 5000;
const dummy = new THREE.Object3D();
const instancedGrass = new THREE.InstancedMesh(grassGeometry, grassMaterial, grassCount);

for (let i = 0; i < grassCount; i++) {
  const x = (Math.random() - 0.5) * 100;
  const z = (Math.random() - 0.5) * 100;
  const y = 0;

  dummy.position.set(x, y, z);
  dummy.rotation.y = Math.random() * Math.PI;
  dummy.scale.set(1, Math.random() * 2 + 0.5, 1);
  dummy.updateMatrix();

  instancedGrass.setMatrixAt(i, dummy.matrix);
}

scene.add(instancedGrass);

// Stickman group (perfect stickman proportions and joints)
const stickman = new THREE.Group();

// Materials
const stickMat = new THREE.MeshStandardMaterial({color: 0x181818});
const headMat = new THREE.MeshStandardMaterial({color: 0xffffff});

// Head (proportionally large)
const head = new THREE.Mesh(
new THREE.SphereGeometry(0.28, 32, 32),
headMat
);
head.position.y = 2.25;
stickman.add(head);

// Body (spine)
const body = new THREE.Mesh(
new THREE.CylinderGeometry(0.06, 0.06, 0.95, 20),
stickMat
);
body.position.y = 1.5;
stickman.add(body);

// Shoulders (joint)
const shoulders = new THREE.Mesh(
new THREE.SphereGeometry(0.09, 20, 16),
stickMat
);
shoulders.position.y = 1.98;
stickman.add(shoulders);

// Hips (joint)
const hips = new THREE.Mesh(
new THREE.SphereGeometry(0.085, 18, 12),
stickMat
);
hips.position.y = 1.02;
stickman.add(hips);

// Arms and Legs as groups for animation
// LEFT ARM
const leftArm = new THREE.Group();
leftArm.position.set(-0.19, 1.9, 0);
stickman.add(leftArm);

// Upper arm
const upperArmL = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14),
stickMat
);
upperArmL.position.y = -0.245;
leftArm.add(upperArmL);

// Elbow
const elbowL = new THREE.Mesh(
new THREE.SphereGeometry(0.06, 12, 10),
stickMat
);
elbowL.position.y = -0.49;
leftArm.add(elbowL);

// Forearm
const leftForearm = new THREE.Group();
leftForearm.position.y = -0.49;
const lowerArmL = new THREE.Mesh(
new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12),
stickMat
);
lowerArmL.position.y = -0.21;
leftForearm.add(lowerArmL);

// Wrist/Hand
const handL = new THREE.Mesh(
new THREE.SphereGeometry(0.045, 10, 8),
stickMat
);
handL.position.y = -0.42;
leftForearm.add(handL);

leftArm.add(leftForearm);

// RIGHT ARM
const rightArm = new THREE.Group();
rightArm.position.set(0.19, 1.9, 0);
stickman.add(rightArm);

const upperArmR = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 14),
stickMat
);
upperArmR.position.y = -0.245;
rightArm.add(upperArmR);

const elbowR = new THREE.Mesh(
new THREE.SphereGeometry(0.06, 12, 10),
stickMat
);
elbowR.position.y = -0.49;
rightArm.add(elbowR);

const rightForearm = new THREE.Group();
rightForearm.position.y = -0.49;
const lowerArmR = new THREE.Mesh(
new THREE.CylinderGeometry(0.04, 0.04, 0.42, 12),
stickMat
);
lowerArmR.position.y = -0.21;
rightForearm.add(lowerArmR);

const handR = new THREE.Mesh(
new THREE.SphereGeometry(0.045, 10, 8),
stickMat
);
handR.position.y = -0.42;
rightForearm.add(handR);

rightArm.add(rightForearm);

// LEFT LEG
const leftLeg = new THREE.Group();
leftLeg.position.set(-0.07, 0.99, 0);
stickman.add(leftLeg);

// Thigh
const upperLegL = new THREE.Mesh(
new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14),
stickMat
);
upperLegL.position.y = -0.29;
leftLeg.add(upperLegL);

// Knee
const kneeL = new THREE.Mesh(
new THREE.SphereGeometry(0.07, 12, 8),
stickMat
);
kneeL.position.y = -0.58;
leftLeg.add(kneeL);

// Shin
const leftShin = new THREE.Group();
leftShin.position.y = -0.58;
const lowerLegL = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12),
stickMat
);
lowerLegL.position.y = -0.245;
leftShin.add(lowerLegL);

// Foot
const footL = new THREE.Mesh(
new THREE.SphereGeometry(0.05, 10, 8),
stickMat
);
footL.position.y = -0.49;
leftShin.add(footL);

leftLeg.add(leftShin);

// RIGHT LEG
const rightLeg = new THREE.Group();
rightLeg.position.set(0.07, 0.99, 0);
stickman.add(rightLeg);

// Thigh
const upperLegR = new THREE.Mesh(
new THREE.CylinderGeometry(0.055, 0.055, 0.58, 14),
stickMat
);
upperLegR.position.y = -0.29;
rightLeg.add(upperLegR);

// Knee
const kneeR = new THREE.Mesh(
new THREE.SphereGeometry(0.07, 12, 8),
stickMat
);
kneeR.position.y = -0.58;
rightLeg.add(kneeR);

// Shin
const rightShin = new THREE.Group();
rightShin.position.y = -0.58;
const lowerLegR = new THREE.Mesh(
new THREE.CylinderGeometry(0.045, 0.045, 0.49, 12),
stickMat
);
lowerLegR.position.y = -0.245;
rightShin.add(lowerLegR);

// Foot
const footR = new THREE.Mesh(
new THREE.SphereGeometry(0.05, 10, 8),
stickMat
);
footR.position.y = -0.49;
rightShin.add(footR);

rightLeg.add(rightShin);

scene.add(stickman);

  // ===== Car Setup =====
const car = new THREE.Group();

// body
const body = new THREE.Mesh(
  new THREE.BoxGeometry(1.6, 0.5, 3),
  new THREE.MeshStandardMaterial({ color: 0x3399ff })
);
car.add(body);

// roof
const roof = new THREE.Mesh(
  new THREE.BoxGeometry(1.2, 0.4, 1.4),
  new THREE.MeshStandardMaterial({ color: 0x2266aa })
);
roof.position.set(0, 0.45, -0.3);
car.add(roof);

// wheels
function wheel(x, z) {
  const w = new THREE.Mesh(
    new THREE.CylinderGeometry(0.35, 0.35, 0.25, 16),
    new THREE.MeshStandardMaterial({ color: 0x111111 })
  );
  w.rotation.z = Math.PI / 2;
  w.position.set(x, -0.3, z);
  car.add(w);
}
wheel(0.9, 1.2);
wheel(-0.9, 1.2);
wheel(0.9, -1.2);
wheel(-0.9, -1.2);

car.position.set(5, 0, 0);
scene.add(car);

// ===== Car State =====
let inCar = false;
let carVel = 0, carAngle = 0;
const carAcc = 0.002, carBrake = 0.004, carFriction = 0.0015, carMax = 0.12, carTurn = 0.03;

let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

window.addEventListener("keydown", e => {
  switch (e.key) {
    case "w": moveForward = true; break;
    case "s": moveBackward = true; break;
    case "a": moveLeft = true; break;
    case "d": moveRight = true; break;
    case "e":
      if (!inCar) {
        if (stickman.position.distanceTo(car.position) < 3) {
          inCar = true;
          stickman.visible = false;
        }
      } else {
        inCar = false;
        stickman.visible = true;
        stickman.position.set(car.position.x + 2, 0, car.position.z);
      }
      break;
  }
});

window.addEventListener("keyup", e => {
  switch (e.key) {
    case "w": moveForward = false; break;
    case "s": moveBackward = false; break;
    case "a": moveLeft = false; break;
    case "d": moveRight = false; break;
  }
});

  if (inCar) {
  // car driving physics
  if (moveForward) carVel += carAcc;
  if (moveBackward) carVel -= carBrake;
  if (carVel > carMax) carVel = carMax;
  if (carVel < -carMax / 2) carVel = -carMax / 2;

  if (moveLeft) carAngle += carTurn * carVel / 0.05;
  if (moveRight) carAngle -= carTurn * carVel / 0.05;

  car.position.x += Math.sin(carAngle) * carVel * 60;
  car.position.z += Math.cos(carAngle) * carVel * 60;
  car.rotation.y = carAngle;

  // friction
  if (!moveForward && !moveBackward) {
    if (carVel > 0) carVel = Math.max(0, carVel - carFriction);
    else if (carVel < 0) carVel = Math.min(0, carVel + carFriction);
  }

  // follow car with camera (you can tweak)
  camera.position.lerp(new THREE.Vector3(
    car.position.x + Math.sin(carAngle) * -8,
    car.position.y + 4,
    car.position.z + Math.cos(carAngle) * -8
  ), 0.1);
  camera.lookAt(car.position);

} else {
// Movement state
let moveBackward = false, moveForward = false, moveLeft = false, moveRight = false;
let isRunning = false;
let isJumping = false;
let isGrounded = true;
let velocityY = 0;
const walkSpeed = 0.08;
const runSpeed = 0.16;
const jumpStrength = 0.24;
const gravity = 0.012;
let walkCycle = 0; // for gait animation

  // Camera control variables
let azimuth = 0;
let polar = Math.PI/5;
let radius = 8;
const minPolar = 0.1;
const maxPolar = Math.PI/2 - 0.05;

// Arrow key camera rotation
const arrowRotationSpeed = 0.03;
window.addEventListener('keydown', function(e){
switch(e.key) {
case 'w': moveBackward = true; break;
case 's': moveForward = true; break;
case 'a': moveLeft = true; break;
case 'd': moveRight = true; break;
case 'Shift': isRunning = true; break;
case ' ':
  if (isGrounded && !isJumping) {
    isJumping = true;
    velocityY = jumpStrength;
  }
  break;
case '1': cameraMode = 1; break;
case '2': cameraMode = 2; break;
case '3': cameraMode = 3; break;
// Arrow camera control
case 'ArrowLeft': azimuth += arrowRotationSpeed; break; // FIXED: was -=
case 'ArrowRight': azimuth -= arrowRotationSpeed; break; // FIXED: was +=
case 'ArrowUp': polar += arrowRotationSpeed; polar = Math.max(minPolar, Math.min(maxPolar, polar)); break; // FIXED: was -=
case 'ArrowDown': polar -= arrowRotationSpeed; polar = Math.max(minPolar, Math.min(maxPolar, polar)); break; // FIXED: was +=
}
});
}

  
window.addEventListener('keydown', function(e){
switch(e.key) {
case 'w': moveBackward = true; break;
case 's': moveForward = true; break;
case 'a': moveLeft = true; break;
case 'd': moveRight = true; break;
case 'Shift': isRunning = true; break;
case ' ': 
if (isGrounded && !isJumping) {
isJumping = true;
velocityY = jumpStrength;
}
break;
case '1': cameraMode = 1; break;
case '2': cameraMode = 2; break;
case '3': cameraMode = 3; break;
}
});

window.addEventListener('keyup', function(e){
switch(e.key) {
case 'w': moveBackward = false; break;
case 's': moveForward = false; break;
case 'a': moveLeft = false; break;
case 'd': moveRight = false; break;
case 'Shift': isRunning = false; break;
}
});
// Mouse orbit controls
let lastMouse = {x: window.innerWidth/2, y: window.innerHeight/2};
let mouseInitialized = false;
const mouseSensitivity = 0.005;

document.addEventListener('mousemove', function(e){
if (cameraMode === 2) return;
if (!mouseInitialized) {
lastMouse.x = e.clientX; lastMouse.y = e.clientY;
mouseInitialized = true;
return;
}
let dx = e.clientX - lastMouse.x;
let dy = e.clientY - lastMouse.y;
azimuth += dx * mouseSensitivity; // FIXED: was -=
polar += dy * mouseSensitivity; // FIXED: was -=
polar = Math.max(minPolar, Math.min(maxPolar, polar));
lastMouse.x = e.clientX;
lastMouse.y = e.clientY;
});

document.addEventListener('mouseleave', function(){
mouseInitialized = false;
});

renderer.domElement.addEventListener('wheel', function(e){
if (cameraMode === 2) return;
radius += e.deltaY * 0.01;
radius = Math.max(2, Math.min(30, radius));
});

function updateCamera() {
  if (cameraMode === 1) { // third-person
    let camX = stickman.position.x + radius * Math.sin(polar) * Math.sin(azimuth);
    let camY = stickman.position.y + radius * Math.cos(polar) + 1;
    let camZ = stickman.position.z + radius * Math.sin(polar) * Math.cos(azimuth);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(stickman.position.x, stickman.position.y + 1.4, stickman.position.z);
  } else if (cameraMode === 2) { // first-person
    // Position camera at head height, looking forward relative to azimuth
    camera.position.set(stickman.position.x, stickman.position.y + 2.25, stickman.position.z);
    // Calculate lookAt point in front of the stickman based on azimuth angle
    const lookX = stickman.position.x + Math.sin(azimuth);
    const lookY = stickman.position.y + 2.25;
    const lookZ = stickman.position.z + Math.cos(azimuth);
    camera.lookAt(lookX, lookY, lookZ);
  } else if (cameraMode === 3) { // top-down
    let camX = stickman.position.x + radius * Math.sin(azimuth);
    let camY = stickman.position.y + 15;
    let camZ = stickman.position.z + radius * Math.cos(azimuth);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(stickman.position.x, stickman.position.y, stickman.position.z);
  }
}

// Animation logic
function animateStickman(state) {
// state: "idle", "walk", "run", "jump"
let t = walkCycle;

if (state === "idle") {
leftArm.rotation.x = 0;
rightArm.rotation.x = 0;
leftForearm.rotation.x = 0;
rightForearm.rotation.x = 0;
leftLeg.rotation.x = 0;
rightLeg.rotation.x = 0;
leftShin.rotation.x = 0;
rightShin.rotation.x = 0;
} else if (state === "walk") {
// Walk: relaxed, natural swing
let freq = 5;
let ampArm = 0.65;
let ampLeg = 0.7;
let shinamp = 0.47;
let phase = t * freq;

leftArm.rotation.x = Math.sin(phase) * ampArm;
rightArm.rotation.x = Math.sin(phase + Math.PI) * ampArm;
leftForearm.rotation.x = 0;
rightForearm.rotation.x = 0;

leftLeg.rotation.x = Math.sin(phase) * ampLeg;
rightLeg.rotation.x = Math.sin(phase + Math.PI) * ampLeg;
leftShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4)) * shinamp;
rightShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 4 + Math.PI)) * shinamp;
} else if (state === "run") {
// RUN: powerful, high knee, arms bent, more forward lean & arm bend
let freq = 9.5;
let ampArm = 1.6;
let ampLeg = 1.8;
let shinamp = 1.35;
let phase = t * freq;

// Arms: more bent, strong swing
leftArm.rotation.x = Math.sin(phase) * ampArm * 0.6;
rightArm.rotation.x = Math.sin(phase + Math.PI) * ampArm * 0.6;
leftForearm.rotation.x = Math.abs(Math.sin(phase)) * 0.9 - 1.1; // arms bent in front
rightForearm.rotation.x = Math.abs(Math.sin(phase + Math.PI)) * 0.9 - 1.1;

// Legs: high knee, strong kickback
leftLeg.rotation.x = Math.sin(phase) * ampLeg;
rightLeg.rotation.x = Math.sin(phase + Math.PI) * ampLeg;
leftShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 6)) * shinamp + 0.13 * Math.abs(Math.sin(phase)); // more extension
rightShin.rotation.x = Math.max(0, -Math.sin(phase + Math.PI / 6 + Math.PI)) * shinamp + 0.13 * Math.abs(Math.sin(phase + Math.PI));
} else if (state === "jump") {
leftArm.rotation.x = -1.15;
rightArm.rotation.x = -1.15;
leftForearm.rotation.x = -0.42;
rightForearm.rotation.x = -0.42;
leftLeg.rotation.x = 0.88;
rightLeg.rotation.x = 0.88;
leftShin.rotation.x = 0.8;
rightShin.rotation.x = 0.8;
}
}

// Animate
function animate() {
  requestAnimationFrame(animate);

  if(inCar){
    // Car physics
    if(carMoveForward) carVel += carAcc;
    if(carMoveBackward) carVel -= carAcc;
    if(carVel > carMax) carVel = carMax;
    if(carVel < -carMax/2) carVel = -carMax/2;

    if(carMoveLeft) carAngle += carTurn * (carVel/carMax);
    if(carMoveRight) carAngle -= carTurn * (carVel/carMax);

    car.position.x += Math.sin(carAngle) * carVel * 60;
    car.position.z += Math.cos(carAngle) * carVel * 60;
    car.rotation.y = carAngle;

    // friction
    if(!carMoveForward && !carMoveBackward){
      if(carVel>0) carVel = Math.max(0, carVel - carFriction);
      else if(carVel<0) carVel = Math.min(0, carVel + carFriction);
    }

    // Camera follows car
    const camTarget = new THREE.Vector3(
      car.position.x - Math.sin(carAngle) * 8,
      car.position.y + 4,
      car.position.z - Math.cos(carAngle) * 8
    );
    camera.position.lerp(camTarget, 0.1);
    camera.lookAt(car.position);

  } else {
    // Original stickman movement & animation
    let speed = isRunning ? runSpeed : walkSpeed;
    let dx = 0, dz = 0;
    if (moveForward) dz -= speed;
    if (moveBackward) dz += speed;
    if (moveLeft) dx -= speed;
    if (moveRight) dx += speed;

    stickman.position.x += dx * Math.cos(azimuth) - dz * Math.sin(azimuth);
    stickman.position.z += dz * Math.cos(azimuth) + dx * Math.sin(azimuth);

    // Gravity & jumping
    if(!isGrounded){
      velocityY -= gravity;
      stickman.position.y += velocityY;
      if(stickman.position.y <= 0){
        stickman.position.y = 0;
        isGrounded = true;
        isJumping = false;
        velocityY = 0;
      }
    } else if(isJumping){
      isGrounded = false;
    }

    if(dx!==0 || dz!==0) walkCycle += speed;
    animateStickman(isJumping ? "jump" : (isRunning ? "run" : (dx!==0 || dz!==0 ? "walk" : "idle")));

    // Camera follows stickman
    updateCamera();
  }

  renderer.render(scene, camera);
}

animate();


// Face direction of movement (except top-down)
if (cameraMode !== 3 && (dx !== 0 || dz !== 0)) {
stickman.rotation.y = Math.atan2(dx, dz);
}

// Animation state
let state = "idle";
if(isJumping || !isGrounded) state = "jump";
else if(dx !== 0 || dz !== 0) state = isRunning ? "run" : "walk";
animateStickman(state);

// KEY CHANGE: run animation is slower
if(state === "walk" || state === "run") walkCycle += isRunning ? 0.024 : 0.024;
else walkCycle += 0.012;

updateCamera();
renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', function() {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
