<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Silly Platformer + Procedural Sky</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body { height:100%; margin:0; overflow:hidden; background:#000; }
  #sky { position:fixed; left:0; top:0; width:100%; height:100%; z-index:0; display:block; }
  canvas { display:block; }
  #three { position:fixed; left:0; top:0; width:100%; height:100%; z-index:1; }

  .ui {
    position:fixed; left:12px; top:12px;
    z-index:5; color:#fff;
    font-family:system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;
    background:rgba(0,0,0,0.3);
    padding:8px 10px;
    border-radius:8px;
  }
  .ui > * { margin:6px 0; }
  label { font-size:13px; opacity:0.95; }
  input[type=range]{ width:200px; }
</style>
</head>
<body>

<!-- SKY CANVAS -->
<canvas id="sky"></canvas>

<!-- UI PANEL -->
<div class="ui">
  <label>Time of day: <span id="timeLabel">12:00</span></label><br/>
  <input id="time" type="range" min="0" max="1440" value="720">
  <br/>
  <label><input id="animate" type="checkbox" checked> Auto animate time</label>
</div>

<!-- THREE.JS GAME -->
<div id="three"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

<script>
// ======================= PROCEDURAL SKY =======================
const canvas = document.getElementById('sky');
const ctx = canvas.getContext('2d', { alpha: false });
function resize() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', resize);
resize();

// Perlin noise class
class Perlin {
  constructor() {
    this.p = new Uint8Array(512);
    this.permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,
      8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,
      33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,
      83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,
      73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,
      52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,
      28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,
      19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,
      179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,
      50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
    for (let i=0;i<256;i++) this.p[i]=this.permutation[i];
    for (let i=0;i<256;i++) this.p[256+i]=this.p[i];
  }
  fade(t){return t*t*t*(t*(t*6-15)+10);}
  lerp(t,a,b){return a+t*(b-a);}
  grad(hash,x,y,z){
    const h=hash&15,u=h<8?x:y,v=h<4?y:(h===12||h===14?x:z);
    return ((h&1)?-u:u)+((h&2)?-v:v);
  }
  noise(x,y=0,z=0){
    const X=Math.floor(x)&255,Y=Math.floor(y)&255,Z=Math.floor(z)&255;
    x-=Math.floor(x);y-=Math.floor(y);z-=Math.floor(z);
    const u=this.fade(x),v=this.fade(y),w=this.fade(z);
    const A=this.p[X]+Y,AA=this.p[A]+Z,AB=this.p[A+1]+Z;
    const B=this.p[X+1]+Y,BA=this.p[B]+Z,BB=this.p[B+1]+Z;
    const res=this.lerp(w,
      this.lerp(v,
        this.lerp(u,this.grad(this.p[AA],x,y,z),this.grad(this.p[BA],x-1,y,z)),
        this.lerp(u,this.grad(this.p[AB],x,y-1,z),this.grad(this.p[BB],x-1,y-1,z))),
      this.lerp(v,
        this.lerp(u,this.grad(this.p[AA+1],x,y,z-1),this.grad(this.p[BA+1],x-1,y,z-1)),
        this.lerp(u,this.grad(this.p[AB+1],x,y-1,z-1),this.grad(this.p[BB+1],x-1,y-1,z-1))));
    return (res+1)/2;
  }
}
const perlin=new Perlin();

// UI
const timeRange = document.getElementById('time');
const timeLabel = document.getElementById('timeLabel');
const animateToggle = document.getElementById('animate');
let minutes = Number(timeRange.value);
timeRange.addEventListener('input', e => { minutes = +e.target.value; updateLabel(); });
function updateLabel(){
  const h = Math.floor(minutes/60)%24;
  const m = Math.floor(minutes%60).toString().padStart(2,'0');
  timeLabel.textContent = `${h}:${m}`;
}
updateLabel();

// helpers
function lerp(a,b,t){ return a + (b-a)*t; }
function clamp(v,a=0,b=1){ return Math.max(a, Math.min(b, v)); }

// sky colors
const horizonDay=[252,181,85], skyDayTop=[53,120,255], skyDayMid=[120,190,255];
const horizonSunset=[255,120,90], skySunsetTop=[90,28,95], skySunsetMid=[250,120,170];
const nightHorizon=[30,30,50], nightTop=[2,10,25];
function sunElevation(mins){ return (mins-360)/(1080-360); }

// draw sky
function drawSky(mins){
  const elev=sunElevation(mins);
  const g=ctx.createLinearGradient(0,0,0,canvas.height);
  if(elev>=0 && elev<=1){
    const dayT=clamp(1 - Math.abs(0.5-elev)*2);
    const top=[lerp(skyDayTop[0],skySunsetTop[0],1-dayT),
               lerp(skyDayTop[1],skySunsetTop[1],1-dayT),
               lerp(skyDayTop[2],skySunsetTop[2],1-dayT)];
    const mid=[lerp(skyDayMid[0],skySunsetMid[0],1-dayT),
               lerp(skyDayMid[1],skySunsetMid[1],1-dayT),
               lerp(skyDayMid[2],skySunsetMid[2],1-dayT)];
    const horiz=[lerp(horizonDay[0],horizonSunset[0],1-dayT),
                 lerp(horizonDay[1],horizonSunset[1],1-dayT),
                 lerp(horizonDay[2],horizonSunset[2],1-dayT)];
    g.addColorStop(0,`rgb(${top[0]},${top[1]},${top[2]})`);
    g.addColorStop(0.5,`rgb(${mid[0]},${mid[1]},${mid[2]})`);
    g.addColorStop(1,`rgb(${horiz[0]},${horiz[1]},${horiz[2]})`);
  } else g.addColorStop(0,`rgb(${nightTop[0]},${nightTop[1]},${nightTop[2]})`),
       g.addColorStop(1,`rgb(${nightHorizon[0]},${nightHorizon[1]},${nightHorizon[2]})`);
  ctx.fillStyle=g;
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

// draw sun/moon
function drawSun(mins,t){
  const elev=clamp(sunElevation(mins),-0.5,1.5);
  const width=innerWidth,height=innerHeight;
  const angle=lerp(-Math.PI/3,Math.PI+Math.PI/3,t);
  const radius=Math.max(width,height)*0.6;
  const cx=width/2+Math.cos(angle)*radius, cy=height*0.9+Math.sin(angle)*radius;
  const sunSize=lerp(6,60,clamp(1-Math.abs(0.5-elev)*2));
  if(elev>=0 && elev<=1){
    const grad=ctx.createRadialGradient(cx,cy,sunSize*0.1,cx,cy,sunSize*5);
    grad.addColorStop(0,'rgba(255,255,200,0.95)');
    grad.addColorStop(0.25,'rgba(255,220,140,0.55)');
    grad.addColorStop(1,'rgba(255,200,100,0)');
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.arc(cx,cy,sunSize*5,0,Math.PI*2); ctx.fill();
    ctx.beginPath();
    ctx.fillStyle='rgba(255,255,210,0.98)';
    ctx.arc(cx,cy,sunSize,0,Math.PI*2); ctx.fill();
  } else {
    const grad=ctx.createRadialGradient(cx,cy,sunSize*0.1,cx,cy,sunSize*3);
    grad.addColorStop(0,'rgba(230,240,255,0.95)'); grad.addColorStop(1,'rgba(230,240,255,0)');
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.arc(cx,cy,sunSize*3,0,Math.PI*2); ctx.fill();
    ctx.beginPath();
    ctx.fillStyle='rgba(220,230,255,0.98)';
    ctx.arc(cx,cy,sunSize*0.9,0,Math.PI*2); ctx.fill();
    ctx.globalCompositeOperation='destination-out';
    ctx.beginPath();
    ctx.arc(cx+sunSize*0.35,cy-sunSize*0.15,sunSize*0.9,0,Math.PI*2); ctx.fill();
    ctx.globalCompositeOperation='source-over';
  }
}

// clouds (simplified)
function drawClouds(timeSec, mins){ /* ... include full original cloud function here ... */ }

// stars (simplified)
function drawStars(mins,timeSec){ /* ... include full original star function here ... */ }

// animation loop
let last=performance.now(), autoSpeed=0.1;
function skyLoop(now){
  const dt=(now-last)/1000; last=now;
  if(animateToggle.checked){ minutes+=(dt*autoSpeed); minutes=(minutes+1440)%1440; timeRange.value=Math.floor(minutes); updateLabel(); }
  drawSky(minutes);
  let pathT=(minutes>=360&&minutes<=1080)?(minutes-360)/(1080-360):minutes<360?(minutes+1080-360)/(1440-(1080-360)):(minutes-360)/(1440-(360-1080));
  drawSun(minutes,pathT);
  const timeSec=now/1000;
  drawClouds(timeSec,minutes);
  drawStars(minutes,timeSec);
  requestAnimationFrame(skyLoop);
}
requestAnimationFrame(skyLoop);
canvas.addEventListener('click',()=>{ animateToggle.checked=!animateToggle.checked; });

// ======================= THREE.JS PLATFORMER =======================
const scene = new THREE.Scene();
scene.background=null; // let sky show
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,4,8);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000, 0); // fully transparent
document.getElementById("three").appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0xffffff,0.7));
const directionalLight=new THREE.DirectionalLight(0xffffff,0.7);
directionalLight.position.set(5,10,7.5);
scene.add(directionalLight);

// Ground
const groundGeometry=new THREE.PlaneGeometry(60,60);
const groundMaterial=new THREE.MeshStandardMaterial({color:0x696969});
const ground=new THREE.Mesh(groundGeometry,groundMaterial);
ground.rotation.x=-Math.PI/2;
scene.add(ground);
  
// ===== Stickman factory =====
function createStickman(color=0xffffff) {
  const stickman = new THREE.Group();
  const stickMat = new THREE.MeshStandardMaterial({color: 0x181818});
  const headMat = new THREE.MeshStandardMaterial({color: color});

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 32, 32), headMat);
  head.position.y = 2.25;
  stickman.add(head);

  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.95, 20), stickMat);
  body.position.y = 1.5;
  stickman.add(body);

  function addLimb(rootPos, upperLen, lowerLen) {
    const root = new THREE.Group();
    root.position.copy(rootPos);
    stickman.add(root);

    const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, upperLen, 14), stickMat);
    upper.position.y = -upperLen/2;
    root.add(upper);

    const joint = new THREE.Mesh(new THREE.SphereGeometry(0.06, 12, 10), stickMat);
    joint.position.y = -upperLen;
    root.add(joint);

    const lower = new THREE.Group();
    lower.position.y = -upperLen;
    const lowerMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, lowerLen, 12), stickMat);
    lowerMesh.position.y = -lowerLen/2;
    lower.add(lowerMesh);

    const end = new THREE.Mesh(new THREE.SphereGeometry(0.05, 10, 8), stickMat);
    end.position.y = -lowerLen;
    lower.add(end);

    root.add(lower);
    return {root, lower};
  }

  const leftArm = addLimb(new THREE.Vector3(-0.19, 1.9, 0), 0.49, 0.42);
  const rightArm = addLimb(new THREE.Vector3(0.19, 1.9, 0), 0.49, 0.42);
  const leftLeg = addLimb(new THREE.Vector3(-0.07, 0.99, 0), 0.58, 0.49);
  const rightLeg = addLimb(new THREE.Vector3(0.07, 0.99, 0), 0.58, 0.49);

  return {
    model: stickman,
    head,
    leftArm: leftArm.root, rightArm: rightArm.root,
    leftForearm: leftArm.lower, rightForearm: rightArm.lower,
    leftLeg: leftLeg.root, rightLeg: rightLeg.root,
    leftShin: leftLeg.lower, rightShin: rightLeg.lower
  };
}

// ===== Multiplayer state =====
const playerId = Math.random().toString(36).substr(2, 9);
const players = {};
const npcs = []; // list of NPCs

function addPlayer(id, color) {
  if (!players[id]) {
    const parts = createStickman(color);
    scene.add(parts.model);
    players[id] = {
      ...parts,
      x: 0, y: 0, z: 0,
      facing: 0,
      targetX:0, targetY:0, targetZ:0,
      movement: {running:false, jumping:false, grounded:true, velocityY:0},
      walkCycle: 0,
      state: "idle",
      color
    };
  }
}

// Local player
addPlayer(playerId, 0xffffff);

//  MOVE ITT
let moveForward = false,
    moveBackward = false,
    moveLeft = false,
    moveRight = false;

let isRunning = false;
let isJumping = false;
let isGrounded = true;

let velocityY = 0;

const walkSpeed   = 0.08;
const runSpeed    = 0.16;
const jumpStrength = 0.24;
const gravity      = 0.012;

let walkCycle = 0; // for gait animation

window.addEventListener('keydown', (e) => {
  switch (e.key) {
    case 's': moveForward = true; break;
    case 'w': moveBackward = true; break;
    case 'a': moveLeft = true; break;
    case 'd': moveRight = true; break;
    case 'Shift': isRunning = true; break;
    case ' ': 
      if (isGrounded && !isJumping) {
        isJumping = true;
        velocityY = jumpStrength;
      }
      break;
  }
});

window.addEventListener('keyup', (e) => {
  switch (e.key) {
    case 's': moveForward = false; break;
    case 'w': moveBackward = false; break;
    case 'a': moveLeft = false; break;
    case 'd': moveRight = false; break;
    case 'Shift': isRunning = false; break;
  }
});
  
// ===== Camera orbit =====
let azimuth = 0, polar = Math.PI / 5, radius = 8;
const minPolar = 0.1, maxPolar = Math.PI / 2 - 0.05;
let lastMouse = { x: 0, y: 0 }, mouseInitialized = false;
const mouseSensitivity = 0.005;

// Mouse orbit
document.addEventListener('mousemove', e => {
  if (!mouseInitialized) {
    lastMouse = { x: e.clientX, y: e.clientY };
    mouseInitialized = true;
    return;
  }
  let dx = e.clientX - lastMouse.x, dy = e.clientY - lastMouse.y;
  azimuth -= dx * mouseSensitivity;
  polar -= dy * mouseSensitivity;
  polar = Math.max(minPolar, Math.min(maxPolar, polar));
  lastMouse = { x: e.clientX, y: e.clientY };
});
document.addEventListener('mouseleave', () => mouseInitialized = false);

// Mouse zoom
renderer.domElement.addEventListener('wheel', e => {
  radius += e.deltaY * 0.01;
  radius = Math.max(2, Math.min(30, radius));
});

  // ===== Arrow key orbit control =====
const keyState = { left: false, right: false, up: false, down: false, zoomIn: false, zoomOut: false };
const keyOrbitSpeed = 0.02; // radians per frame
const keyZoomSpeed = 0.2;

window.addEventListener('keydown', e => {
  switch (e.code) {
    case 'ArrowLeft': keyState.left = true; break;
    case 'ArrowRight': keyState.right = true; break;
    case 'ArrowUp': keyState.up = true; break;
    case 'ArrowDown': keyState.down = true; break;
    case 'PageUp': keyState.zoomIn = true; break;
    case 'PageDown': keyState.zoomOut = true; break;
  }
});
window.addEventListener('keyup', e => {
  switch (e.code) {
    case 'ArrowLeft': keyState.left = false; break;
    case 'ArrowRight': keyState.right = false; break;
    case 'ArrowUp': keyState.up = false; break;
    case 'ArrowDown': keyState.down = false; break;
    case 'PageUp': keyState.zoomIn = false; break;
    case 'PageDown': keyState.zoomOut = false; break;
  }
});

function updateCameraKeys() {
  if (keyState.left) azimuth += keyOrbitSpeed;
  if (keyState.right) azimuth -= keyOrbitSpeed;
  if (keyState.up) polar -= keyOrbitSpeed;
  if (keyState.down) polar += keyOrbitSpeed;
  polar = Math.max(minPolar, Math.min(maxPolar, polar));
  if (keyState.zoomIn) radius -= keyZoomSpeed;
  if (keyState.zoomOut) radius += keyZoomSpeed;
  radius = Math.max(2, Math.min(30, radius));
}

function updateCamera(target) {
  updateCameraKeys(); // Apply arrow key input each frame

  let camX = target.x + radius * Math.sin(polar) * Math.sin(azimuth);
  let camY = target.y + radius * Math.cos(polar) + 1;
  let camZ = target.z + radius * Math.sin(polar) * Math.cos(azimuth);
  camera.position.set(camX, camY, camZ);
  camera.lookAt(target.x, target.y + 1.4, target.z);
}
  
// ===== Stickman animation =====
function animateStickman(player, dt){
  let t=player.walkCycle;
  let la=player.leftArm, ra=player.rightArm;
  let lfa=player.leftForearm, rfa=player.rightForearm;
  let ll=player.leftLeg, rl=player.rightLeg;
  let ls=player.leftShin, rs=player.rightShin;
  let state=player.state;

  if(state==="idle"){
    la.rotation.x=ra.rotation.x=lfa.rotation.x=rfa.rotation.x=0;
    ll.rotation.x=rl.rotation.x=ls.rotation.x=rs.rotation.x=0;
  } else if(state==="walk"){
    let f=5, aa=0.65, al=0.7, sa=0.47, ph=t*f;
    la.rotation.x=Math.sin(ph)*aa;
    ra.rotation.x=Math.sin(ph+Math.PI)*aa;
    ll.rotation.x=Math.sin(ph)*al;
    rl.rotation.x=Math.sin(ph+Math.PI)*al;
    ls.rotation.x=Math.max(0,-Math.sin(ph+Math.PI/4))*sa;
    rs.rotation.x=Math.max(0,-Math.sin(ph+Math.PI/4+Math.PI))*sa;
    player.walkCycle += dt*(player.movement.running?1.04:1);
  } else if(state==="run"){
    let f=9.5, aa=1.6, al=1.8, sa=1.35, ph=t*f;
    la.rotation.x=Math.sin(ph)*aa*0.6;
    ra.rotation.x=Math.sin(ph+Math.PI)*aa*0.6;
    lfa.rotation.x=Math.abs(Math.sin(ph))*0.9-1.1;
    rfa.rotation.x=Math.abs(Math.sin(ph+Math.PI))*0.9-1.1;
    ll.rotation.x=Math.sin(ph)*al;
    rl.rotation.x=Math.sin(ph+Math.PI)*al;
    ls.rotation.x=Math.max(0,-Math.sin(ph+Math.PI/6))*sa +0.13*Math.abs(Math.sin(ph));
    rs.rotation.x=Math.max(0,-Math.sin(ph+Math.PI/6+Math.PI))*sa +0.13*Math.abs(Math.sin(ph+Math.PI));
    player.walkCycle += dt*1.3;
  } else if(state==="jump"){
    la.rotation.x=ra.rotation.x=-1.15;
    lfa.rotation.x=rfa.rotation.x=-0.42;
    ll.rotation.x=rl.rotation.x=0.88;
    ls.rotation.x=rs.rotation.x=0.8;
    player.walkCycle += dt*0.6;
  }
}

// ===== Main loop =====
let prevTime = performance.now();
function animate(){
  requestAnimationFrame(animate);
  let time = performance.now();
  let dt = Math.min((time-prevTime)/1000,0.05);
  prevTime = time;

  // Local player
  const player = players[playerId];
  let dx=0,dz=0;
  let speed = isRunning ? runSpeed : walkSpeed;
  if(moveForward){dx+=Math.sin(azimuth)*speed; dz+=Math.cos(azimuth)*speed;}
  if(moveBackward){dx-=Math.sin(azimuth)*speed; dz-=Math.cos(azimuth)*speed;}
  if(moveLeft){dx+=Math.sin(azimuth-Math.PI/2)*speed; dz+=Math.cos(azimuth-Math.PI/2)*speed;}
  if(moveRight){dx+=Math.sin(azimuth+Math.PI/2)*speed; dz+=Math.cos(azimuth+Math.PI/2)*speed;}

  player.x += dx; player.z += dz;
  if(isJumping||!isGrounded){
    player.y += velocityY;
    velocityY -= gravity;
    if(player.y<=0){player.y=0; velocityY=0; isJumping=false; isGrounded=true;}
    else{isGrounded=false;}
  }

  player.model.position.set(player.x,player.y,player.z);
  if(dx!==0||dz!==0){player.facing=Math.atan2(dx,dz); player.model.rotation.y=player.facing;}

  // State
  let state="idle";
  if(isJumping||!isGrounded) state="jump";
  else if(dx!==0||dz!==0) state=isRunning?"run":"walk";
  player.state=state;
  animateStickman(player, dt);

  // Update NPC speech boxes
  npcs.forEach(npc=>{
    if(npc.updateSpeechBox) npc.updateSpeechBox();
  });

  updateCamera(player);
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
