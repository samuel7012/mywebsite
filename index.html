<html lang="en">
<head>
<meta charset="UTF-8">
<title>Stickman :P</title>
<style>
body { margin: 0; overflow: hidden; background: #111; }
#info {
  position: absolute; top: 10px; left: 10px;
  color: #fff; background: rgba(0,0,0,0.5);
  padding: 8px; border-radius: 5px; font-family: sans-serif;
}
#bottom-bar {
  position: fixed;
  left: 0; right: 0; bottom: 0;
  height: 60px;
  background: rgba(40,40,40,0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 99;
  gap: 24px;
}
#npc-btn, #sword-btn, #axe-btn, #staff-btn {
  background: #2e8bff;
  color: #fff;
  border: none;
  border-radius: 8px;
  padding: 13px 24px;
  font-size: 17px;
  cursor: pointer;
  transition: background 0.2s;
  box-shadow: 0 2px 8px #0005;
}
#npc-btn:hover, #sword-btn:hover, #axe-btn:hover, #staff-btn:hover {
  background: #1768c9;
}
</style>
</head>
<body>
<div id="info" style="width:98%; height:11%;">
  <marquee direction="right">
    <span class="flashEm">
      <b>W</b>/<b>A</b>/<b>S</b>/<b>D</b> to move |
      Hold <b>Shift</b> to run, <b>Space</b> to jump |
      Arrow keys to rotate/zoom camera |
      Click weapon button to equip to right hand |
      Drag red dots to move limbs (physics!) |
      Stickman single-player demo
    </span>
  </marquee>
</div>
<div id="bottom-bar">
  <button id="npc-btn">Spawn NPC</button>
  <button id="sword-btn">Equip Sword</button>
  <button id="axe-btn">Equip Axe</button>
  <button id="staff-btn">Equip Staff</button>
</div>

<style>
.flashEm {
  animation: flashItalic 1s infinite steps(1, start);
}
@keyframes flashItalic {
  0%, 100% { font-style: normal; }
  50% { font-style: italic; }
}
</style>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
<script>
// ===== Scene setup =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222233);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 8);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// ====== Physics setup ======
const world = new CANNON.World({
  gravity: new CANNON.Vec3(0, -9.82, 0)
});
world.broadphase = new CANNON.NaiveBroadphase();
world.solver.iterations = 10;

const groundBody = new CANNON.Body({
  shape: new CANNON.Plane(),
  mass: 0,
  material: new CANNON.Material()
});
groundBody.quaternion.setFromEuler(-Math.PI/2,0,0);
world.addBody(groundBody);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Ground
const groundGeometry = new THREE.PlaneGeometry(60, 60);
const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x696969 });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// ===== 3D Weapons =====
function removeWeaponFromHand(hand) {
  while (hand.children.length > 0) hand.remove(hand.children[0]);
}
function equipWeaponToHand(hand, weaponModel) {
  removeWeaponFromHand(hand);
  hand.add(weaponModel);
}
function createSword() {
  const sword = new THREE.Group();
  const blade = new THREE.Mesh(
    new THREE.BoxGeometry(0.07, 0.44, 0.06),
    new THREE.MeshStandardMaterial({color: 0xd0d0d0, metalness:0.5, roughness:0.25})
  );
  blade.position.y = 0.22;
  sword.add(blade);
  const guard = new THREE.Mesh(
    new THREE.BoxGeometry(0.18, 0.05, 0.065),
    new THREE.MeshStandardMaterial({color: 0x86632c, metalness:0.4, roughness:0.6})
  );
  guard.position.y = 0.02;
  sword.add(guard);
  const handle = new THREE.Mesh(
    new THREE.CylinderGeometry(0.028, 0.028, 0.14, 12),
    new THREE.MeshStandardMaterial({color: 0x603b17})
  );
  handle.position.y = -0.07;
  sword.add(handle);
  const pommel = new THREE.Mesh(
    new THREE.SphereGeometry(0.032, 10, 8),
    new THREE.MeshStandardMaterial({color: 0x666666, metalness:0.5})
  );
  pommel.position.y = -0.14;
  sword.add(pommel);
  sword.rotation.z = Math.PI / 2.5;
  sword.position.set(0.08, 0, 0);
  return sword;
}
function createAxe() {
  const axe = new THREE.Group();
  const handle = new THREE.Mesh(
    new THREE.CylinderGeometry(0.025, 0.03, 0.36, 10),
    new THREE.MeshStandardMaterial({color: 0x8b5c2b})
  );
  handle.position.y = -0.04;
  axe.add(handle);
  const blade = new THREE.Mesh(
    new THREE.BoxGeometry(0.19, 0.08, 0.11),
    new THREE.MeshStandardMaterial({color: 0xbfcbe2, metalness:0.5, roughness:0.2})
  );
  blade.position.set(0.09, 0.08, 0);
  blade.rotation.z = Math.PI/11;
  axe.add(blade);
  const back = new THREE.Mesh(
    new THREE.CylinderGeometry(0.018, 0.018, 0.05, 10),
    new THREE.MeshStandardMaterial({color: 0x444444})
  );
  back.position.set(-0.09, 0.08, 0);
  back.rotation.x = Math.PI/2;
  axe.add(back);
  axe.rotation.z = Math.PI/2.15;
  axe.position.set(0.08, 0, 0);
  return axe;
}
function createStaff() {
  const staff = new THREE.Group();
  const shaft = new THREE.Mesh(
    new THREE.CylinderGeometry(0.022, 0.027, 0.61, 12),
    new THREE.MeshStandardMaterial({color: 0x8b6c3d})
  );
  shaft.position.y = 0.19;
  staff.add(shaft);
  const orb = new THREE.Mesh(
    new THREE.SphereGeometry(0.06, 18, 10),
    new THREE.MeshStandardMaterial({color: 0x6cf4e7, emissive:0x1b8e8a, emissiveIntensity:0.6, transparent:true, opacity:0.85})
  );
  orb.position.y = 0.52;
  staff.add(orb);
  const band = new THREE.Mesh(
    new THREE.TorusGeometry(0.045, 0.012, 7, 20),
    new THREE.MeshStandardMaterial({color: 0xccc4b0, metalness:0.7, roughness:0.2})
  );
  band.position.y = 0.47;
  band.rotation.x = Math.PI/2;
  staff.add(band);
  staff.rotation.z = Math.PI / 2.15;
  staff.position.set(0.08, 0, 0);
  return staff;
}
document.getElementById('sword-btn').onclick = function() {
  equipWeaponToHand(player.rightHand, createSword());
  showEquipHint('Sword');
};
document.getElementById('axe-btn').onclick = function() {
  equipWeaponToHand(player.rightHand, createAxe());
  showEquipHint('Axe');
};
document.getElementById('staff-btn').onclick = function() {
  equipWeaponToHand(player.rightHand, createStaff());
  showEquipHint('Staff');
};
function showEquipHint(weaponName) {
  if (!document.getElementById("equip-hint")) {
    let hint = document.createElement("div");
    hint.id = "equip-hint";
    hint.innerHTML = weaponName + " equipped!";
    hint.style.position = "fixed";
    hint.style.bottom = "70px";
    hint.style.left = "50%";
    hint.style.transform = "translateX(-50%)";
    hint.style.background = "rgba(0,0,0,0.7)";
    hint.style.color = "#ffe";
    hint.style.padding = "9px 20px";
    hint.style.borderRadius = "7px";
    hint.style.fontFamily = "sans-serif";
    hint.style.fontSize = "17px";
    hint.style.zIndex = "100";
    document.body.appendChild(hint);
    setTimeout(() => { if(hint.parentNode) hint.parentNode.removeChild(hint); }, 1400);
  }
}

// ===== Physics Stickman Factory (cannon.js) =====
function createPhysicsStickman(color=0xffffff) {
  const stickman = new THREE.Group();
  const stickMat = new THREE.MeshStandardMaterial({color: 0x181818});
  const headMat = new THREE.MeshStandardMaterial({color: color});

  // Physics objects
  function makeSphereBody(radius, mass, pos) {
    const shape = new CANNON.Sphere(radius);
    const body = new CANNON.Body({ mass: mass, shape: shape, position: pos });
    world.addBody(body);
    return body;
  }
  function makeCapsuleBody(radius, height, mass, pos) {
    // Capsule approximation as two spheres and a cylinder
    const group = new CANNON.Body({ mass: mass });
    const cylShape = new CANNON.Cylinder(radius, radius, height, 10);
    group.addShape(cylShape, new CANNON.Vec3(0, 0, 0), new CANNON.Quaternion());
    const sphereA = new CANNON.Sphere(radius);
    group.addShape(sphereA, new CANNON.Vec3(0, height/2, 0));
    group.addShape(sphereA, new CANNON.Vec3(0, -height/2, 0));
    group.position.copy(pos);
    world.addBody(group);
    return group;
  }

  // Head
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.28, 32, 32), headMat);
  head.position.y = 2.25;
  stickman.add(head);
  const headBody = makeSphereBody(0.28, 1, new CANNON.Vec3(0,2.25,0));

  // Body
  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.95, 20), stickMat);
  body.position.y = 1.5;
  stickman.add(body);
  const bodyBody = makeCapsuleBody(0.06, 0.95, 1.5, new CANNON.Vec3(0,1.5,0));

  // Limbs (arms & legs)
  function addLimb(rootPos, upperLen, lowerLen, isArm) {
    // Upper limb
    const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, upperLen, 14), stickMat);
    upper.position.set(rootPos.x, rootPos.y-upperLen/2, rootPos.z);
    stickman.add(upper);
    const upperBody = makeCapsuleBody(0.045, upperLen, 0.4, new CANNON.Vec3(rootPos.x, rootPos.y-upperLen/2, rootPos.z));

    // Lower limb
    const lower = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, lowerLen, 12), stickMat);
    lower.position.set(rootPos.x, rootPos.y-upperLen-lowerLen/2, rootPos.z);
    stickman.add(lower);
    const lowerBody = makeCapsuleBody(0.04, lowerLen, 0.3, new CANNON.Vec3(rootPos.x, rootPos.y-upperLen-lowerLen/2, rootPos.z));

    // Joint: connect upper to lower
    const c = new CANNON.ConeTwistConstraint(upperBody, lowerBody, {
      pivotA: new CANNON.Vec3(0, -upperLen/2, 0),
      pivotB: new CANNON.Vec3(0, lowerLen/2, 0),
      axisA: new CANNON.Vec3(1,0,0),
      axisB: new CANNON.Vec3(1,0,0),
      angle: Math.PI/3
    });
    world.addConstraint(c);

    // Attach upper to body (or to head for arms)
    if (isArm) {
      const attach = new CANNON.ConeTwistConstraint(bodyBody, upperBody, {
        pivotA: new CANNON.Vec3(rootPos.x, 0.42, 0),
        pivotB: new CANNON.Vec3(0, upperLen/2, 0),
        axisA: new CANNON.Vec3(1,0,0),
        axisB: new CANNON.Vec3(1,0,0),
        angle: Math.PI/3
      });
      world.addConstraint(attach);
    } else {
      const attach = new CANNON.ConeTwistConstraint(bodyBody, upperBody, {
        pivotA: new CANNON.Vec3(rootPos.x, -0.47, 0),
        pivotB: new CANNON.Vec3(0, upperLen/2, 0),
        axisA: new CANNON.Vec3(1,0,0),
        axisB: new CANNON.Vec3(1,0,0),
        angle: Math.PI/3
      });
      world.addConstraint(attach);
    }
    return {
      upper, upperBody, lower, lowerBody
    };
  }
  // Arms
  const leftArm = addLimb(new THREE.Vector3(-0.19, 1.9, 0), 0.49, 0.42, true);
  const rightArm = addLimb(new THREE.Vector3(0.19, 1.9, 0), 0.49, 0.42, true);
  // Legs
  const leftLeg = addLimb(new THREE.Vector3(-0.07, 0.99, 0), 0.58, 0.49, false);
  const rightLeg = addLimb(new THREE.Vector3(0.07, 0.99, 0), 0.58, 0.49, false);

  // Right hand for weapon
  const rightHand = new THREE.Group();
  rightHand.position.set(0, -0.42, 0);
  rightArm.lower.add(rightHand);

  // Handles for dragging
  function makeLimbHandle(limb, color) {
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), new THREE.MeshBasicMaterial({ color }));
    mesh.position.set(0, -0.49/2, 0);
    limb.lower.add(mesh);
    return mesh;
  }
  // Red handles for each lower limb
  const handles = [
    makeLimbHandle(leftArm, 0xff4444),
    makeLimbHandle(rightArm, 0xff4444),
    makeLimbHandle(leftLeg, 0xff4444),
    makeLimbHandle(rightLeg, 0xff4444)
  ];

  return {
    model: stickman,
    head, headBody,
    body, bodyBody,
    leftArm, rightArm, leftLeg, rightLeg,
    handles, // For drag
    rightHand,
    physicsLimbs: [
      {mesh:leftArm.upper, body:leftArm.upperBody},
      {mesh:leftArm.lower, body:leftArm.lowerBody},
      {mesh:rightArm.upper, body:rightArm.upperBody},
      {mesh:rightArm.lower, body:rightArm.lowerBody},
      {mesh:leftLeg.upper, body:leftLeg.upperBody},
      {mesh:leftLeg.lower, body:leftLeg.lowerBody},
      {mesh:rightLeg.upper, body:rightLeg.upperBody},
      {mesh:rightLeg.lower, body:rightLeg.lowerBody},
      {mesh:body, body:bodyBody},
      {mesh:head, body:headBody}
    ]
  };
}

// ===== Player setup (physics stickman) =====
const player = createPhysicsStickman(0xffffff);
scene.add(player.model);

// ===== Limb Drag (cannon.js) =====
let dragConstraint = null;
let dragBody = null;
let dragOffset = new CANNON.Vec3();
renderer.domElement.addEventListener('mousedown', function(e){
  // Raycast to handles
  const rect = renderer.domElement.getBoundingClientRect();
  const mouse = {
    x: ((e.clientX-rect.left)/rect.width)*2-1,
    y: -((e.clientY-rect.top)/rect.height)*2+1
  };
  const pointer = new THREE.Vector2(mouse.x, mouse.y);
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(pointer, camera);
  const intersects = raycaster.intersectObjects(player.handles, false);
  if(intersects.length > 0){
    // Find which limb
    const idx = player.handles.indexOf(intersects[0].object);
    if(idx !== -1){
      dragBody = player.physicsLimbs[idx*2+1].body; // lower limb body
      // Get intersection point in world coords
      let intersectPoint = intersects[0].point;
      // Body local offset
      dragOffset = dragBody.pointToLocalFrame(new CANNON.Vec3(intersectPoint.x,intersectPoint.y,intersectPoint.z));
      // Constraint from body to a fixed point in space
      dragConstraint = new CANNON.PointToPointConstraint(
        dragBody, dragOffset,
        null, new CANNON.Vec3(intersectPoint.x,intersectPoint.y,intersectPoint.z)
      );
      world.addConstraint(dragConstraint);
    }
  }
});
renderer.domElement.addEventListener('mousemove', function(e){
  if(dragConstraint){
    // Move constraint pivot to new mouse projection on ground plane (y=0), or use ray from camera
    const rect = renderer.domElement.getBoundingClientRect();
    const mouse = {
      x: ((e.clientX-rect.left)/rect.width)*2-1,
      y: -((e.clientY-rect.top)/rect.height)*2+1
    };
    const pointer = new THREE.Vector2(mouse.x, mouse.y);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(pointer, camera);
    // Intersect with y=0 plane
    const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
    const intersect = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, intersect);
    if (intersect) {
      dragConstraint.pivotB.copy(new CANNON.Vec3(intersect.x, intersect.y, intersect.z));
    }
  }
});
renderer.domElement.addEventListener('mouseup', function(e){
  if(dragConstraint){
    world.removeConstraint(dragConstraint);
    dragConstraint = null;
    dragBody = null;
  }
});

// ===== Controls =====
let moveForward = false,
    moveBackward = false,
    moveLeft = false,
    moveRight = false;
let isRunning = false;
let isJumping = false;
let isGrounded = true;
let velocityY = 0;

const walkSpeed   = 0.08;
const runSpeed    = 0.16;
const jumpStrength = 0.24;
const gravity      = 0.012;

// ===== Camera orbit (Arrow keys only) =====
let azimuth = 0, polar = Math.PI/5, radius = 8;
const minPolar = 0.1, maxPolar = Math.PI/2-0.05;
const minRadius = 2, maxRadius = 30;
const camAzimuthStep = 0.06;
const camPolarStep = 0.04;
const camRadiusStep = 0.5;

window.addEventListener('keydown', (e) => {
  switch (e.key) {
    case 's': moveForward = true; break;
    case 'w': moveBackward = true; break;
    case 'a': moveLeft = true; break;
    case 'd': moveRight = true; break;
    case 'Shift': isRunning = true; break;
    case 'ArrowLeft':
      azimuth -= camAzimuthStep;
      break;
    case 'ArrowRight':
      azimuth += camAzimuthStep;
      break;
    case 'ArrowUp':
      polar -= camPolarStep;
      polar = Math.max(minPolar, Math.min(maxPolar, polar));
      break;
    case 'ArrowDown':
      polar += camPolarStep;
      polar = Math.max(minPolar, Math.min(maxPolar, polar));
      break;
    case '+': case '=':
      radius -= camRadiusStep;
      radius = Math.max(minRadius, Math.min(maxRadius, radius));
      break;
    case '-':
      radius += camRadiusStep;
      radius = Math.max(minRadius, Math.min(maxRadius, radius));
      break;
    case ' ':
      if (isGrounded && !isJumping) {
        isJumping = true;
        velocityY = jumpStrength;
      }
      break;
  }
});

window.addEventListener('keyup', (e) => {
  switch (e.key) {
    case 's': moveForward = false; break;
    case 'w': moveBackward = false; break;
    case 'a': moveLeft = false; break;
    case 'd': moveRight = false; break;
    case 'Shift': isRunning = false; break;
  }
});

function updateCamera(target){
  let camX=target.x+radius*Math.sin(polar)*Math.sin(azimuth);
  let camY=target.y+radius*Math.cos(polar)+1;
  let camZ=target.z+radius*Math.sin(polar)*Math.cos(azimuth);
  camera.position.set(camX, camY, camZ);
  camera.lookAt(target.x, target.y+1.4, target.z);
}

// ===== Main loop =====
let prevTime = performance.now();
function animate(){
  requestAnimationFrame(animate);

  // Step physics
  world.step(1/60);

  // Sync physics to mesh
  player.physicsLimbs.forEach(({mesh, body}) => {
    mesh.position.copy(body.position);
    mesh.quaternion.copy(body.quaternion);
  });

  // Camera follows player body
  updateCamera({x:player.bodyBody.position.x, y:player.bodyBody.position.y, z:player.bodyBody.position.z});

  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
