<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stickman with Waving Grass</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #info {
      position: absolute; top: 10px; left: 10px;
      color: white; background: rgba(0, 0, 0, 0.5);
      padding: 8px; font-family: sans-serif; border-radius: 5px;
    }
  </style>
</head>
<body>
<div id="info">
  <b>W</b>: backward &nbsp; <b>S</b>: forward &nbsp; <b>A</b>: left &nbsp; <b>D</b>: right<br>
  Hold <b>Shift</b> to run, <b>Space</b> to jump<br>
  <b>1</b>: Third-person &nbsp; <b>2</b>: First-person &nbsp; <b>3</b>: Top-down<br>
  Move <b>mouse</b> to rotate camera, <b>Scroll</b> to zoom
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>

<script>
// === Basic Scene Setup ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x88ccff);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
camera.position.set(0, 4, 8);
let cameraMode = 1;

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// === Lighting ===
scene.add(new THREE.HemisphereLight(0xffffff, 0x223344, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(10, 20, 10);
scene.add(dirLight);

// === Waving Grass Ground ===
const grassVertex = `
  uniform float time;
  varying vec2 vUv;
  void main() {
    vUv = uv;
    vec3 pos = position;
    float wave = sin((position.x + time * 2.0) * 0.5) * 0.2;
    pos.y += wave * (1.0 - uv.y);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
`;

const grassFragment = `
  varying vec2 vUv;
  void main() {
    gl_FragColor = vec4(0.1 + 0.3*vUv.y, 0.5 + 0.4*vUv.y, 0.1, 1.0);
  }
`;

const grassUniforms = {
  time: { value: 0 }
};

const grassMaterial = new THREE.ShaderMaterial({
  uniforms: grassUniforms,
  vertexShader: grassVertex,
  fragmentShader: grassFragment,
  side: THREE.DoubleSide
});

const bladeGeo = new THREE.PlaneGeometry(0.1, 1, 1, 4);
bladeGeo.translate(0, 0.5, 0);

const blades = 10000;
const instanced = new THREE.InstancedMesh(bladeGeo, grassMaterial, blades);
scene.add(instanced);

const dummy = new THREE.Object3D();
for (let i = 0; i < blades; i++) {
  const x = (Math.random() - 0.5) * 500;
  const z = (Math.random() - 0.5) * 500;
  dummy.position.set(x, 0, z);
  dummy.rotation.y = Math.random() * Math.PI;
  dummy.scale.setScalar(0.5 + Math.random() * 0.5);
  dummy.updateMatrix();
  instanced.setMatrixAt(i, dummy.matrix);
}

// === Simple Stickman Body ===
const stickman = new THREE.Group();
const mat = new THREE.MeshStandardMaterial({ color: 0x222222 });
const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffffff }));
head.position.y = 2.2;
stickman.add(head);
const body = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1.2, 12), mat);
body.position.y = 1.4;
stickman.add(body);
const leg1 = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.7, 10), mat);
leg1.position.set(-0.1, 0.35, 0);
stickman.add(leg1);
const leg2 = leg1.clone();
leg2.position.x = 0.1;
stickman.add(leg2);
scene.add(stickman);

// === Movement ===
let move = { forward: false, back: false, left: false, right: false, run: false, jump: false };
let velocityY = 0;
const speed = 0.08;
const jumpStrength = 0.22;
const gravity = 0.01;

document.addEventListener('keydown', e => {
  if (e.key === 'w') move.forward = true;
  if (e.key === 's') move.back = true;
  if (e.key === 'a') move.left = true;
  if (e.key === 'd') move.right = true;
  if (e.key === 'Shift') move.run = true;
  if (e.key === ' ') move.jump = true;
  if (e.key === '1') cameraMode = 1;
  if (e.key === '2') cameraMode = 2;
  if (e.key === '3') cameraMode = 3;
});
document.addEventListener('keyup', e => {
  if (e.key === 'w') move.forward = false;
  if (e.key === 's') move.back = false;
  if (e.key === 'a') move.left = false;
  if (e.key === 'd') move.right = false;
  if (e.key === 'Shift') move.run = false;
  if (e.key === ' ') move.jump = false;
});

// === Mouse View ===
let azimuth = 0;
let polar = Math.PI / 4;
let radius = 8;
document.addEventListener('mousemove', e => {
  if (cameraMode === 2) return;
  if (e.buttons !== 1) return;
  azimuth -= e.movementX * 0.005;
  polar -= e.movementY * 0.005;
  polar = Math.max(0.1, Math.min(Math.PI / 2.2, polar));
});

document.addEventListener('wheel', e => {
  if (cameraMode !== 2) {
    radius += e.deltaY * 0.01;
    radius = Math.max(2, Math.min(30, radius));
  }
});

// === Animation Loop ===
function animate() {
  requestAnimationFrame(animate);

  const dir = new THREE.Vector3();
  if (move.forward) dir.z -= 1;
  if (move.back) dir.z += 1;
  if (move.left) dir.x -= 1;
  if (move.right) dir.x += 1;
  if (dir.lengthSq() > 0) dir.normalize();

  let moveSpeed = move.run ? speed * 2 : speed;
  const moveX = dir.x * moveSpeed;
  const moveZ = dir.z * moveSpeed;

  const angle = azimuth;
  stickman.position.x += Math.sin(angle) * moveZ + Math.sin(angle - Math.PI/2) * moveX;
  stickman.position.z += Math.cos(angle) * moveZ + Math.cos(angle - Math.PI/2) * moveX;

  if (move.jump && stickman.position.y <= 0.01) {
    velocityY = jumpStrength;
  }

  velocityY -= gravity;
  stickman.position.y += velocityY;
  if (stickman.position.y < 0) {
    stickman.position.y = 0;
    velocityY = 0;
  }

  if (cameraMode === 1) {
    const camX = stickman.position.x + radius * Math.sin(polar) * Math.sin(azimuth);
    const camY = stickman.position.y + radius * Math.cos(polar);
    const camZ = stickman.position.z + radius * Math.sin(polar) * Math.cos(azimuth);
    camera.position.set(camX, camY, camZ);
    camera.lookAt(stickman.position.x, stickman.position.y + 1.5, stickman.position.z);
  } else if (cameraMode === 2) {
    camera.position.set(stickman.position.x, stickman.position.y + 2.2, stickman.position.z);
    camera.lookAt(stickman.position.x, stickman.position.y + 2.2, stickman.position.z + 2);
  } else {
    camera.position.set(stickman.position.x, stickman.position.y + 15, stickman.position.z);
    camera.lookAt(stickman.position.x, stickman.position.y, stickman.position.z);
  }

  grassUniforms.time.value += 0.01;
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
